<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- UPDATE Title -->
    <title>KeyWordManager-V1.4.6</title> <!-- Updated Version -->

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' width='32' height='32'%3E%3Cstyle%3Etext %7B fill: %23000%3B %7D @media (prefers-color-scheme: dark) %7B text %7B fill: %23FFF%3B %7D %7D%3C/style%3E%3Ctext x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' font-family='-apple-system, BlinkMacSystemFont, %22Segoe UI%22, Roboto, Helvetica, Arial, sans-serif' font-size='43' font-weight='bold'%3EKWM%3C/text%3E%3C/svg%3E">

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- CSS Variables --- */
        :root {
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

            --color-text-primary: #24292f;
            --color-text-secondary: #57606a;
            --color-text-placeholder: #6e7781;
            --color-text-link: #0969da;
            --color-text-button: #ffffff;
            --color-text-button-edit: #1f2328;
            --color-text-danger: #d73a49;
            --color-text-icon: #57606a;
            --color-text-info: #6e7781;
            --color-text-entry-active: #ffffff;
            --color-text-suggestion-match: #0550ae;
            --color-bg-body: #f6f8fa;
            --color-bg-container: #ffffff;
            --color-bg-input: #ffffff;
            --color-bg-tag-area: #f6f8fa;
            --color-bg-tag: #eaeef2;
            --color-bg-tag-hover: #dde4eb;
            --color-bg-tag-selected: #0969da;
            --color-bg-action-area: #f1f5f9;
            --color-bg-message-success: #ddf4ff;
            --color-bg-message-error: #ffebe9;
            --color-bg-message-info: #fff8c5;
            --color-bg-placeholder: #f6f8fa;
            --color-bg-placeholder-button-hover: #e1e4e8;
            --color-bg-entry-active: #57606a;
            --color-bg-entry-hover: #e1e4e8;
            --color-bg-suggestions: #ffffff;
            --color-bg-suggestion-hover: #f6f8fa;
            --color-bg-suggestion-active: #eaeef2;
            --color-border-default: #d0d7de;
            --color-border-input-focus: #0969da;
            --color-border-tag: #d0d7de;
            --color-border-tag-selected: #0550ae;
            --color-border-message-success: #b6e3ff;
            --color-border-message-error: #ffccc7;
            --color-border-message-info: #fbe599;
            --color-border-divider: #d8dee4;
            --color-border-entry-active: #424a53;
            --color-border-suggestions: #d0d7de;
            --color-button-primary-bg: #2c974b;
            --color-button-primary-hover: #278742;
            --color-button-primary-active: #22763a;
            --color-button-secondary-bg: #0969da;
            --color-button-secondary-hover: #0550ae;
            --color-button-secondary-active: #034092;
            --color-button-danger-bg: #d73a49;
            --color-button-danger-hover: #bc2c3a;
            --color-button-danger-active: #a42632;
            --color-button-warning-bg: #f5ae1c;
            --color-button-warning-hover: #e19f0f;
            --color-button-warning-active: #cf920c;
            --color-button-default-bg: #f6f8fa;
            --color-button-default-text: #24292f;
            --color-button-default-border: #d0d7de;
            --color-button-default-hover: #f3f5f7;
            --color-button-default-active: #e6ebf0;
            --color-button-disabled-bg: #eaeef2;
            --color-button-disabled-text: #8c959f;
            --color-button-disabled-border: #d0d7de;

            --shadow-small: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-medium: 0 3px 6px rgba(0,0,0,0.07), 0 1px 2px rgba(0,0,0,0.05);
            --shadow-focus: 0 0 0 3px rgba(9, 105, 218, 0.3);
            --shadow-focus-danger: 0 0 0 3px rgba(215, 58, 73, 0.4);
            --shadow-suggestions: 0 4px 12px rgba(0,0,0,0.1);

            --radius-small: 4px;
            --radius-medium: 6px;
            --radius-large: 8px;
            --radius-full: 999px;

            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 12px;
            --spacing-lg: 16px;
            --spacing-xl: 20px;
            --spacing-2xl: 24px;
            --spacing-3xl: 32px;

            --transition-fast: 0.15s ease;
            --transition-default: 0.2s ease;
            --transition-slow: 0.3s ease;
        }

        /* --- Dark Mode Variables --- */
        body.dark-mode {
            --color-text-primary: #c9d1d9;
            --color-text-secondary: #8b949e;
            --color-text-placeholder: #6e7781;
            --color-text-link: #58a6ff;
            --color-text-button: #ffffff;
            --color-text-button-edit: #0d1117;
            --color-text-danger: #f85149;
            --color-text-icon: #8b949e;
            --color-text-info: #6e7781;
            --color-text-entry-active: #0d1117;
            --color-text-suggestion-match: #58a6ff; /* Brighter blue */
            --color-bg-body: #0d1117;
            --color-bg-container: #161b22;
            --color-bg-input: #0d1117;
            --color-bg-tag-area: #1a1f27;
            --color-bg-tag: #21262d;
            --color-bg-tag-hover: #30363d;
            --color-bg-tag-selected: #1f6feb;
            --color-bg-action-area: #1a1f27;
            --color-bg-message-success: #034092;
            --color-bg-message-error: #a42632;
            --color-bg-message-info: #9a6d00;
            --color-bg-placeholder: #1a1f27;
            --color-bg-placeholder-button-hover: #30363d;
            --color-bg-entry-active: #8b949e;
            --color-bg-entry-hover: #3a414a;
            --color-bg-suggestions: #161b22;
            --color-bg-suggestion-hover: #21262d;
            --color-bg-suggestion-active: #30363d;
            --color-border-default: #30363d;
            --color-border-input-focus: #58a6ff;
            --color-border-tag: #30363d;
            --color-border-tag-selected: #0e5ae1;
            --color-border-message-success: #0e5ae1;
            --color-border-message-error: #bc2c3a;
            --color-border-message-info: #cf920c;
            --color-border-divider: #21262d;
            --color-border-entry-active: #aab3ac;
            --color-border-suggestions: #30363d;
            --color-button-primary-bg: #238636;
            --color-button-primary-hover: #2ea043;
            --color-button-primary-active: #34a84d;
            --color-button-secondary-bg: #1f6feb;
            --color-button-secondary-hover: #388bfd;
            --color-button-secondary-active: #58a6ff;
            --color-button-danger-bg: #da3633;
            --color-button-danger-hover: #f85149;
            --color-button-danger-active: #ff6b67;
            --color-button-warning-bg: #d19a00;
            --color-button-warning-hover: #e8ae00;
            --color-button-warning-active: #f5bd00;
            --color-button-default-bg: #21262d;
            --color-button-default-text: #c9d1d9;
            --color-button-default-border: #30363d;
            --color-button-default-hover: #30363d;
            --color-button-default-active: #3a414a;
            --color-button-disabled-bg: #161b22;
            --color-button-disabled-text: #6e7781;
            --color-button-disabled-border: #30363d;

            --shadow-focus: 0 0 0 3px rgba(56, 139, 253, 0.4);
            --shadow-focus-danger: 0 0 0 3px rgba(248, 81, 73, 0.4);
            --shadow-medium: 0 3px 6px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.15);
            --shadow-suggestions: 0 4px 12px rgba(0,0,0,0.25);
        }

        /* --- Base Styles --- */
        *, *::before, *::after { box-sizing: border-box; }
        body { font-family: var(--font-primary); line-height: 1.6; margin: 0; padding: var(--spacing-xl); background-color: var(--color-bg-body); color: var(--color-text-primary); transition: background-color var(--transition-slow), color var(--transition-slow); min-height: 100vh; display: flex; flex-direction: column; }
        a { color: var(--color-text-link); text-decoration: none; }
        a:hover { text-decoration: underline; }
        *:focus-visible { outline: 2px solid var(--color-border-input-focus); outline-offset: 2px; box-shadow: var(--shadow-focus); }
        *:focus:not(:focus-visible) { outline: none; box-shadow: none; }
        [data-variant="danger"]:focus-visible { outline-color: var(--color-text-danger); box-shadow: var(--shadow-focus-danger); }

        /* --- Container --- */
        .container { background-color: var(--color-bg-container); padding: var(--spacing-2xl); border-radius: var(--radius-large); box-shadow: var(--shadow-medium); width: 95%; max-width: 1400px; margin: var(--spacing-3xl) auto; transition: background-color var(--transition-slow), box-shadow var(--transition-default), border var(--transition-default); flex-grow: 1; display: flex; flex-direction: column; border: 3px dashed transparent; position: relative; }

        /* --- Drag/Drop Feedback --- */
        .container.drag-over { border-color: var(--color-border-input-focus); background-color: color-mix(in srgb, var(--color-bg-container) 90%, var(--color-border-input-focus) 10%); }
        .container.drag-over::before { content: 'Drop .json file here'; position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 1.2em; font-weight: 600; color: var(--color-text-link); background-color: rgba(255, 255, 255, 0.8); border-radius: var(--radius-large); z-index: 10; pointer-events: none; }
        body.dark-mode .container.drag-over::before { background-color: rgba(0, 0, 0, 0.8); color: var(--color-text-link); }

        /* --- Headings --- */
        h1, h2 { margin-top: 0; color: var(--color-text-primary); transition: color var(--transition-slow); font-weight: 600; }
        h1 { font-size: 1.8em; margin-bottom: var(--spacing-2xl); width: 100%; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--spacing-md); }
        h2 { font-size: 1.3em; margin-bottom: var(--spacing-lg); border-bottom: 1px solid var(--color-border-divider); padding-bottom: var(--spacing-sm); display: flex; align-items: center; gap: var(--spacing-sm); }
        .left-column h2, .right-column h2 { text-align: left; }
        .file-io h2 { text-align: center; border-bottom: none; margin-bottom: var(--spacing-sm);}

        /* --- Current Filename Display --- */
        #currentFileNameDisplay { font-size: 0.75em; font-weight: 500; color: var(--color-text-secondary); background-color: var(--color-bg-tag); padding: var(--spacing-xs) var(--spacing-md); border-radius: var(--radius-medium); margin-left: auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 40%; transition: background-color var(--transition-default), color var(--transition-default); order: 2; }
        h1 > .title-text { order: 1; }
        #currentFileNameDisplay.unsaved::before { content: '* '; color: var(--color-text-danger); font-weight: bold; }

        /* --- Main Layout --- */
        .main-layout { display: flex; gap: var(--spacing-2xl); flex-grow: 1; overflow: hidden; flex-wrap: wrap; }
        .left-column { flex: 2; min-width: 350px; display: flex; flex-direction: column; }
        .right-column { flex: 1; min-width: 300px; display: flex; flex-direction: column; max-height: calc(100vh - 220px); }

        /* --- Inputs & Search/Filter --- */
        .input-area, .filter-area { margin-bottom: var(--spacing-xl); }
        .input-area { display: flex; flex-direction: column; gap: var(--spacing-md); }
        .filter-area { display: flex; flex-direction: column; gap: var(--spacing-lg); }
        /* Wrapper for input + suggestions */
        .input-wrapper { position: relative; }
        #tagInput, #entryInput, #searchInput, #entryFilterInput { width: 100%; padding: var(--spacing-md); border: 1px solid var(--color-border-default); border-radius: var(--radius-medium); font-size: 1rem; background-color: var(--color-bg-input); color: var(--color-text-primary); transition: border-color var(--transition-fast), box-shadow var(--transition-fast), background-color var(--transition-default), color var(--transition-default); }
        #tagInput::placeholder, #entryInput::placeholder, #searchInput::placeholder, #entryFilterInput::placeholder { color: var(--color-text-placeholder); }
        #tagInput:focus, #entryInput:focus, #searchInput:focus, #entryFilterInput:focus { border-color: var(--color-border-input-focus); outline: 0; box-shadow: var(--shadow-focus); }
        #tagInput:disabled, #entryInput:disabled, #searchInput:disabled, #entryFilterInput:disabled { background-color: var(--color-button-disabled-bg); border-color: var(--color-button-disabled-border); color: var(--color-text-placeholder); cursor: not-allowed; opacity: 0.7; }
        .filter-group label { display: block; margin-bottom: var(--spacing-sm); font-weight: 500; font-size: 0.9em; color: var(--color-text-secondary); }
        #clearSearchBtn, #clearEntryFilterBtn { position: absolute; right: 10px; /* Adjusted top based on label presence */ top: calc(50% + 10px); transform: translateY(-50%); background: none; border: none; padding: 0; margin: 0; font-size: 1.5em; line-height: 1; color: var(--color-text-placeholder); cursor: pointer; display: none; transition: color var(--transition-fast); z-index: 2; }
        #clearSearchBtn:hover, #clearEntryFilterBtn:hover { color: var(--color-text-primary); }
        #searchInput:not(:placeholder-shown):not(:disabled) + #clearSearchBtn, #entryFilterInput:not(:placeholder-shown):not(:disabled) + #clearEntryFilterBtn { display: inline-block; }

        /* --- Button styles --- */
        button, .file-io label.button-like { display: inline-flex; align-items: center; justify-content: center; gap: var(--spacing-sm); padding: var(--spacing-sm) var(--spacing-lg); font-size: 0.95rem; font-weight: 500; font-family: var(--font-primary); border: 1px solid transparent; border-radius: var(--radius-medium); cursor: pointer; white-space: nowrap; vertical-align: middle; user-select: none; transition: background-color var(--transition-fast), border-color var(--transition-fast), color var(--transition-fast), box-shadow var(--transition-fast), transform var(--transition-fast), opacity var(--transition-fast); text-align: center; }
        button svg { width: 1.1em; height: 1.1em; vertical-align: text-bottom; fill: currentColor; }
        button[data-variant="primary"] { background-color: var(--color-button-primary-bg); color: var(--color-text-button); } button[data-variant="primary"]:hover:not(:disabled) { background-color: var(--color-button-primary-hover); transform: translateY(-1px); } button[data-variant="primary"]:active:not(:disabled) { background-color: var(--color-button-primary-active); transform: translateY(0); } button[data-variant="secondary"] { background-color: var(--color-button-secondary-bg); color: var(--color-text-button); } button[data-variant="secondary"]:hover:not(:disabled) { background-color: var(--color-button-secondary-hover); transform: translateY(-1px); } button[data-variant="secondary"]:active:not(:disabled) { background-color: var(--color-button-secondary-active); transform: translateY(0); } button[data-variant="warning"] { background-color: var(--color-button-warning-bg); color: var(--color-text-button-edit); } button[data-variant="warning"]:hover:not(:disabled) { background-color: var(--color-button-warning-hover); transform: translateY(-1px); } button[data-variant="warning"]:active:not(:disabled) { background-color: var(--color-button-warning-active); transform: translateY(0); } button[data-variant="danger"] { background-color: var(--color-button-danger-bg); color: var(--color-text-button); } button[data-variant="danger"]:hover:not(:disabled) { background-color: var(--color-button-danger-hover); transform: translateY(-1px); } button[data-variant="danger"]:active:not(:disabled) { background-color: var(--color-button-danger-active); transform: translateY(0); } button[data-variant="default"], button:not([data-variant]) { background-color: var(--color-button-default-bg); color: var(--color-button-default-text); border-color: var(--color-button-default-border); } button[data-variant="default"]:hover:not(:disabled), button:not([data-variant]):hover:not(:disabled) { background-color: var(--color-button-default-hover); border-color: color-mix(in srgb, var(--color-border-default) 80%, var(--color-text-primary) 20%); transform: translateY(-1px); } button[data-variant="default"]:active:not(:disabled), button:not([data-variant]):active:not(:disabled) { background-color: var(--color-button-default-active); transform: translateY(0); } button:disabled, button:disabled:hover, button:disabled:active { background-color: var(--color-button-disabled-bg); color: var(--color-button-disabled-text); border-color: var(--color-button-disabled-border); cursor: not-allowed; opacity: 0.65; transform: none; box-shadow: none; }
        .input-area > div { display: flex; justify-content: flex-end; gap: var(--spacing-md); }
        button.action-btn { padding: var(--spacing-xs) var(--spacing-md); font-size: 0.85em; }
        button.add-entry-btn { padding: 6px 10px; font-size: 0.8em; }
        button.remove-entry-btn { background: none; border: none; color: var(--color-text-secondary); padding: 0 var(--spacing-xs); margin-left: var(--spacing-xs); font-size: 1.1em; line-height: 1; vertical-align: middle; opacity: 0.6; cursor: pointer; flex-shrink: 0; }
        button.remove-entry-btn:hover { opacity: 1; color: var(--color-text-danger); }
        .action-button-row { display: flex; gap: var(--spacing-md); margin-bottom: var(--spacing-xl); flex-wrap: wrap; align-items: center; }
        .action-button-row > button { margin-bottom: 0; }
        button#saveFileBtn.needs-save { animation: pulse-green 1.5s infinite; }
        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--color-button-primary-bg) 70%, transparent 30%); } 70% { box-shadow: 0 0 0 8px color-mix(in srgb, var(--color-button-primary-bg) 0%, transparent 100%); } 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--color-button-primary-bg) 0%, transparent 100%); } }
        body.dark-mode button#saveFileBtn.needs-save { animation-name: pulse-green-dark; }
        @keyframes pulse-green-dark { 0% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--color-button-primary-bg) 80%, transparent 20%); } 70% { box-shadow: 0 0 0 8px color-mix(in srgb, var(--color-button-primary-bg) 0%, transparent 100%); } 100% { box-shadow: 0 0 0 0 color-mix(in srgb, var(--color-button-primary-bg) 0%, transparent 100%); } }


        /* --- Tag Display & Action styles --- */
        #tagDisplayContainer { flex-grow: 1; display: flex; flex-direction: column; border: 1px solid var(--color-border-default); border-radius: var(--radius-medium); background-color: var(--color-bg-tag-area); transition: background-color var(--transition-default), border-color var(--transition-default); min-height: 250px; position: relative; }
        #tagAreaInitialPlaceholder { display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: var(--spacing-3xl) var(--spacing-lg); color: var(--color-text-secondary); background-color: var(--color-bg-placeholder); border-radius: var(--radius-medium); flex-grow: 1; transition: opacity var(--transition-default); } #tagAreaInitialPlaceholder.hidden { display: none; opacity: 0; pointer-events: none; } #tagAreaInitialPlaceholder svg { width: 64px; height: 64px; margin-bottom: var(--spacing-lg); color: var(--color-text-icon); opacity: 0.7; } #tagAreaInitialPlaceholder span { margin-bottom: var(--spacing-xl); max-width: 300px; line-height: 1.5; } #tagAreaInitialPlaceholder .placeholder-actions {
            display: flex;
            flex-direction: row;
            gap: var(--spacing-md);
            justify-content: center;
        } #tagAreaInitialPlaceholder button {
            font-size: 0.9rem;
            padding: var(--spacing-xs) var(--spacing-md);
        } #tagAreaInitialPlaceholder button#openFilePlaceholderBtn { background-color: var(--color-bg-container); color: var(--color-text-primary); border-color: var(--color-border-default); } #tagAreaInitialPlaceholder button#openFilePlaceholderBtn:hover:not(:disabled) { background-color: var(--color-bg-placeholder-button-hover); border-color: color-mix(in srgb, var(--color-border-default) 80%, var(--color-text-primary) 20%); } body.dark-mode #tagAreaInitialPlaceholder button#openFilePlaceholderBtn { background-color: var(--color-bg-body); color: var(--color-text-primary); border-color: var(--color-border-divider); } body.dark-mode #tagAreaInitialPlaceholder button#openFilePlaceholderBtn:hover:not(:disabled) { background-color: var(--color-bg-placeholder-button-hover); border-color: var(--color-text-secondary); }
        #tagDisplayArea { padding: var(--spacing-lg); line-height: 1.8; word-break: break-word; flex-grow: 1; overflow-y: auto; resize: vertical; min-height: 150px; display: flex; flex-wrap: wrap; gap: var(--spacing-sm); align-content: flex-start; display: none; outline: none; } #tagDisplayArea.visible { display: flex; } #tagDisplayContainer.editing-active #tagDisplayArea span.tag-item { cursor: not-allowed; pointer-events: none; opacity: 0.7; }
        #tagDisplayArea span.tag-item {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            cursor: pointer;
        }
        #tagDisplayArea span.tag-item { cursor: pointer; padding: var(--spacing-xs) var(--spacing-md); background-color: var(--color-bg-tag); border-radius: var(--radius-medium); border: 1px solid var(--color-border-tag); display: inline-flex; align-items: center; transition: background-color var(--transition-fast), border-color var(--transition-fast), color var(--transition-fast), box-shadow var(--transition-fast), transform var(--transition-fast), opacity var(--transition-fast); font-size: 0.95em; position: relative; user-select: none; color: var(--color-text-primary); outline: none; } #tagDisplayArea span.tag-item:hover:not(.selected) { background-color: var(--color-bg-tag-hover); border-color: color-mix(in srgb, var(--color-border-tag) 70%, var(--color-text-primary) 30%); transform: translateY(-1px); } .tag-entry-count { margin-left: var(--spacing-sm); background-color: var(--color-button-secondary-bg); color: var(--color-text-button); border-radius: var(--radius-full); min-width: 18px; height: 18px; padding: 0 5px; font-size: 0.75em; font-weight: 600; display: inline-flex; align-items: center; justify-content: center; line-height: 1; box-shadow: var(--shadow-small); z-index: 1; pointer-events: none; } body.dark-mode .tag-entry-count { background-color: var(--color-button-secondary-hover); color: var(--color-text-button); } #tagDisplayArea span.tag-item.selected { background-color: var(--color-bg-tag-selected); color: var(--color-text-button); border-color: var(--color-border-tag-selected); font-weight: 500; } #tagDisplayArea span.tag-item.selected .tag-entry-count { background-color: var(--color-bg-container); color: var(--color-bg-tag-selected); } body.dark-mode #tagDisplayArea span.tag-item.selected .tag-entry-count { background-color: var(--color-bg-body); color: var(--color-bg-tag-selected); } #tagDisplayArea span.tag-item:focus-visible { outline: 2px solid var(--color-border-input-focus); outline-offset: 1px; box-shadow: none; border-color: var(--color-border-input-focus); }
        #tagActionsArea { margin-top: var(--spacing-xl); padding: var(--spacing-lg); border: none; border-top: 1px solid var(--color-border-divider); border-radius: 0 0 var(--radius-medium) var(--radius-medium); background-color: var(--color-bg-action-area); transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding var(--transition-slow), margin var(--transition-slow), border-top-width 0.3s ease-out; overflow: hidden; max-height: 0; opacity: 0; padding-top: 0; padding-bottom: 0; margin-top: 0; border-top-width: 0; } #tagActionsArea.visible { max-height: 500px; opacity: 1; padding: var(--spacing-lg); margin-top: var(--spacing-xl); border-top-width: 1px; } #tagActionsArea .action-section { margin-bottom: var(--spacing-lg); padding-bottom: var(--spacing-lg); border-bottom: 1px solid var(--color-border-divider); } #tagActionsArea .action-section:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; } #tagActionsArea label { font-weight: 500; display: block; margin-bottom: var(--spacing-sm); font-size: 0.9em; color: var(--color-text-secondary); } #tagActionsArea .action-buttons { display: flex; gap: var(--spacing-sm); flex-wrap: wrap; } #tagActionsArea input[type="text"] { padding: var(--spacing-sm) var(--spacing-md); border: 1px solid var(--color-border-default); border-radius: var(--radius-medium); font-size: 0.9em; background-color: var(--color-bg-input); color: var(--color-text-primary); flex-grow: 1; min-width: 150px; } #tagActionsArea input[type="text"]:focus { border-color: var(--color-border-input-focus); box-shadow: var(--shadow-focus); outline: none; } #tagActionsArea .entries-list { margin-top: var(--spacing-md); font-size: 0.9em; color: var(--color-text-secondary); max-height: 100px; overflow-y: auto; background-color: var(--color-bg-tag); padding: var(--spacing-sm) var(--spacing-md); border-radius: var(--radius-medium); } #tagActionsArea .entries-list span { margin-right: var(--spacing-sm); padding: 2px 6px; background-color: var(--color-border-default); border-radius: var(--radius-small); color: var(--color-text-primary); display: inline-flex; align-items: center; margin-bottom: var(--spacing-xs); font-size: 0.9em; } body.dark-mode #tagActionsArea .entries-list span { background-color: var(--color-border-tag); } #tagActionsArea .entries-list em { color: var(--color-text-placeholder); font-style: italic; }


        /* --- Placeholder & Message Styles --- */
        .placeholder-text { color: var(--color-text-placeholder); font-style: italic; display: flex; align-items: center; justify-content: center; text-align: center; width: 100%; padding: var(--spacing-xl); margin: auto; transition: opacity var(--transition-default); display: none; } .placeholder-text.visible { display: flex; } .placeholder-text svg { width: 32px; height: 32px; margin-right: var(--spacing-md); opacity: 0.5; }
        .message { padding: var(--spacing-md) var(--spacing-lg); margin-top: var(--spacing-xl); margin-bottom: var(--spacing-xl); border-radius: var(--radius-medium); border: 1px solid transparent; text-align: center; font-weight: 500; display: none; font-size: 0.95em; transition: opacity 0.2s ease, transform 0.2s ease; opacity: 0; transform: translateY(-10px); } .message.visible { display: block; opacity: 1; transform: translateY(0); } .message.success { background-color: var(--color-bg-message-success); color: color-mix(in srgb, var(--color-button-secondary-bg) 80%, black 20%); border-color: var(--color-border-message-success); } .message.error { background-color: var(--color-bg-message-error); color: color-mix(in srgb, var(--color-button-danger-bg) 80%, black 20%); border-color: var(--color-border-message-error); } .message.info { background-color: var(--color-bg-message-info); color: color-mix(in srgb, var(--color-button-warning-bg) 70%, black 30%); border-color: var(--color-border-message-info); } body.dark-mode .message.success { color: color-mix(in srgb, var(--color-button-secondary-hover) 80%, white 20%); } body.dark-mode .message.error { color: color-mix(in srgb, var(--color-button-danger-hover) 80%, white 20%); } body.dark-mode .message.info { color: color-mix(in srgb, var(--color-button-warning-hover) 80%, white 20%); }

        /* --- File I/O & Dark Mode styles --- */
        .file-io { margin-top: auto; padding: var(--spacing-2xl) var(--spacing-2xl) var(--spacing-xl); border-top: 1px solid var(--color-border-divider); text-align: center; transition: border-color var(--transition-default); display: flex; flex-wrap: wrap; justify-content: center; gap: var(--spacing-md); margin-left: calc(-1 * var(--spacing-2xl)); margin-right: calc(-1 * var(--spacing-2xl)); margin-bottom: calc(-1 * var(--spacing-2xl)); border-radius: 0 0 var(--radius-large) var(--radius-large); } .file-io h2, .file-io p { flex-basis: 100%; } .file-io p { margin-bottom: var(--spacing-lg); color: var(--color-text-secondary); font-size: 0.9em; } .file-io button { margin: 0; } .file-io input[type="file"] { display: none; } .file-io .file-io-note { flex-basis: 100%; font-size: 0.85em; color: var(--color-text-placeholder); margin-top: var(--spacing-lg); }
        .dark-mode-toggle { position: fixed; top: var(--spacing-xl); right: var(--spacing-xl); background-color: var(--color-bg-tag); color: var(--color-text-primary); border: 1px solid var(--color-border-default); border-radius: var(--radius-medium); padding: var(--spacing-sm) var(--spacing-md); cursor: pointer; font-size: 0.9em; z-index: 1000; transition: background-color var(--transition-default), color var(--transition-default), border-color var(--transition-default); display: flex; align-items: center; gap: var(--spacing-sm); } .dark-mode-toggle:hover { background-color: var(--color-bg-tag-hover); } .dark-mode-toggle svg { width: 1.2em; height: 1.2em; } .dark-mode .dark-mode-toggle .light-icon { display: none; } .dark-mode-toggle .dark-icon { display: none; } .dark-mode .dark-mode-toggle .dark-icon { display: inline-block; }

        /* --- Tag Count Display styles --- */
        #tagCountDisplay { padding: var(--spacing-sm) var(--spacing-lg); font-size: 0.85em; color: var(--color-text-info); text-align: right; border-top: 1px solid var(--color-border-divider); margin-top: var(--spacing-sm); transition: color var(--transition-default), border-color var(--transition-default); }

        /* --- Associated Entries with click interaction) --- */
        .current-entries-section { margin-top: var(--spacing-2xl); border-top: 1px solid var(--color-border-divider); padding-top: var(--spacing-lg); }
        .current-entries-section h2 { font-size: 1.1em; border-bottom: none; margin-bottom: var(--spacing-md); }
        #currentEntriesDisplayArea {
            background-color: var(--color-bg-tag-area);
            border: 1px solid var(--color-border-default);
            border-radius: var(--radius-medium);
            padding: var(--spacing-md);
            min-height: 300px;
            overflow-y: auto;
            resize: vertical;
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
            align-content: flex-start;
        }
        #currentEntriesDisplayArea span.current-entry-item { display: inline-flex; align-items: center; font-size: 0.9em; color: var(--color-text-secondary); background-color: var(--color-bg-tag); padding: var(--spacing-xs) var(--spacing-md); border-radius: var(--radius-medium); border: 1px solid var(--color-border-tag); max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; transition: background-color var(--transition-fast), border-color var(--transition-fast), color var(--transition-fast), transform var(--transition-fast); }
        #currentEntriesDisplayArea span.current-entry-item.clickable { cursor: pointer; user-select: none; } /* Make clickable */
        #currentEntriesDisplayArea span.current-entry-item.clickable:hover { background-color: var(--color-bg-entry-hover); transform: translateY(-1px); }
        #currentEntriesDisplayArea span.current-entry-item.active-filter { background-color: var(--color-bg-entry-active); color: var(--color-text-entry-active); border-color: var(--color-border-entry-active); font-weight: 500; }
        body.dark-mode #currentEntriesDisplayArea span.current-entry-item { background-color: var(--color-bg-tag-hover); color: var(--color-text-secondary); border-color: var(--color-border-tag); }
        body.dark-mode #currentEntriesDisplayArea span.current-entry-item.clickable:hover { background-color: var(--color-bg-entry-hover); }
        body.dark-mode #currentEntriesDisplayArea span.current-entry-item.active-filter { background-color: var(--color-bg-entry-active); color: var(--color-text-entry-active); border-color: var(--color-border-entry-active); }
        #currentEntriesDisplayArea .placeholder-text { font-size: 0.9em; padding: var(--spacing-lg); width: 100%; }
        #currentEntriesCountDisplay { padding: var(--spacing-sm) 0; font-size: 0.8em; color: var(--color-text-info); text-align: right; margin-top: var(--spacing-xs); }

        /* --- Suggestions Dropdown --- */
        .suggestions-container {
            position: absolute;
            background-color: var(--color-bg-suggestions);
            border: 1px solid var(--color-border-suggestions);
            border-top: none; /* Input border serves as top */
            border-radius: 0 0 var(--radius-medium) var(--radius-medium);
            box-shadow: var(--shadow-suggestions);
            max-height: 200px;
            overflow-y: auto;
            width: 100%; /* Match input width */
            z-index: 100; /* Ensure it's above other elements */
            display: none; /* Hidden by default */
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .suggestions-container li {
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            font-size: 0.95rem;
            color: var(--color-text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .suggestions-container li:hover {
            background-color: var(--color-bg-suggestion-hover);
        }
        .suggestions-container li.active { /* For keyboard navigation */
            background-color: var(--color-bg-suggestion-active);
            color: var(--color-text-link); /* Make active item stand out */
            font-weight: 500;
        }
        .suggestions-container li strong { /* Highlight matching part */
            font-weight: 600; /* Or bold */
            color: var(--color-text-suggestion-match);
        }
        .suggestions-container li.no-suggestion {
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--color-text-placeholder);
            font-style: italic;
            cursor: default;
        }

        /* Tooltip styles for entry hover */
        .entry-tooltip {
            position: fixed; /* Use fixed positioning */
            background-color: var(--color-bg-container);
            border: 1px solid var(--color-border-default);
            border-radius: var(--radius-medium);
            padding: var(--spacing-sm) var(--spacing-md); /* Use consistent padding */
            box-shadow: var(--shadow-medium);
            z-index: 1000;
            max-width: 300px;
            font-size: 0.9em;
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--transition-fast);
            transform: translate(10px, 10px); /* Offset from cursor */
            white-space: nowrap; /* Prevent text wrapping for the container */
            overflow: hidden; /* Clip if somehow content overflows */
        }
        .entry-tooltip.visible {
            opacity: 1;
        }
        /* Added style for wrapped content inside tooltip */
        .entry-tooltip .tooltip-content-wrap {
            white-space: normal;
        }


/* Tag tooltip styles */
.tag-tooltip {
    position: fixed; /* Use fixed positioning */
    background-color: var(--color-bg-container);
    border: 1px solid var(--color-border-default);
    border-radius: var(--radius-medium);
    padding: var(--spacing-sm) var(--spacing-md); /* Use consistent padding */
    box-shadow: var(--shadow-medium);
    z-index: 1000;
    max-width: 300px;
    font-size: 0.9em;
    pointer-events: none;
    opacity: 0;
    transition: opacity var(--transition-fast);
    transform: translate(10px, 10px); /* Offset from cursor */
    white-space: normal; /* Allow text wrapping */
}

.tag-tooltip.visible {
    opacity: 1;
}

.current-entry-item {
    cursor: pointer; /* Make it clear it's interactive */
}


/* --- Footer existing styles --- */
footer { text-align: center; margin-top: var(--spacing-2xl); padding: var(--spacing-xl) 0 0 0; font-size: 0.9em; color: var(--color-text-secondary); border-top: 1px solid var(--color-border-divider); transition: color var(--transition-default), border-color var(--transition-default); width: 100%; } footer p { margin-bottom: var(--spacing-sm); }

/* --- Section Header & Fit Button --- */
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-md); /* Adjust spacing as needed */
    gap: var(--spacing-md);
}

.section-header h2 {
    margin-bottom: 0; /* Remove default margin from h2 */
    border-bottom: none; /* Remove border if we don't want it per section */
    flex-grow: 1; /* Allow h2 to take space */
}

/* Style for the fit button itself */
button.fit-button {
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: 0.8em;
    line-height: 1;
    background-color: var(--color-bg-tag);
    color: var(--color-text-secondary);
    border: 1px solid var(--color-border-default);
    flex-shrink: 0; /* Prevent shrinking */
}
button.fit-button:hover {
    background-color: var(--color-bg-tag-hover);
    color: var(--color-text-primary);
}
button.fit-button svg {
   width: 1em; height: 1em; vertical-align: middle;
}
button.fit-button span { vertical-align: middle; margin-left: var(--spacing-xs); }

/* Make h2 border span full width again if needed (adjust if section-header used elsewhere) */
.left-column .section-header + #tagDisplayContainer h2,
.right-column .section-header + #currentEntriesDisplayArea h2 {

}
/* Ensure h2 has the border bottom style originally intended */
.left-column .section-header h2,
.right-column .section-header h2 {
 border-bottom: 1px solid var(--color-border-divider);
 padding-bottom: var(--spacing-sm);
}
.right-column .current-entries-section .section-header h2 {
 /* Prevent double border */
 border-bottom: none;
 padding-bottom: 0;
}


/* --- Responsive Adjustments styles --- */
@media (max-width: 850px) {
    body { padding: var(--spacing-lg); } /* Keep large padding for tablets */
    .container { margin: var(--spacing-xl) auto; padding: var(--spacing-xl); }
    h1 {
        flex-direction: column; /* Stack title and filename */
        align-items: center;
        gap: var(--spacing-md); /* Slightly more gap */
        text-align: center;
        font-size: 1.7em; /* Slightly reduce font size */
    }
    #currentFileNameDisplay {
        max-width: 80%;
        margin-left: 0; /* Center below title */
        order: 2;
        font-size: 0.7em; /* Slightly smaller filename */
    }
    h1 > .title-text { order: 1; }
    .main-layout {
        flex-direction: column; /* Stack columns */
        overflow: visible; /* Allow content to determine height */
    }
    .right-column {
        max-height: none; /* Remove height restriction */
        margin-top: var(--spacing-2xl); /* Increase space between stacked columns */
    }
    #tagDisplayContainer { min-height: 200px; } /* Keep min-height */
    .file-io {
        margin-left: 0;
        margin-right: 0;
        margin-bottom: 0;
        border-radius: var(--radius-medium);
        padding: var(--spacing-xl);
        gap: var(--spacing-lg); /* More gap for buttons */
    }
    .file-io button {
       flex-basis: calc(50% - var(--spacing-md)); /* Try to fit 2 buttons per row */
       flex-grow: 1;
   }
   .dark-mode-toggle { top: var(--spacing-md); right: var(--spacing-md); }
   .current-entries-section { margin-top: var(--spacing-xl); }
   #currentEntriesDisplayArea { max-height: 200px; } /* Keep max-height */
}

/* Intermediate adjustments for smaller tablets / larger phones */
@media (max-width: 600px) {
    body { padding: var(--spacing-md); } /* Reduce body padding */
    .container { padding: var(--spacing-lg); } /* Reduce container padding */
    h1 { font-size: 1.6em; } /* Further reduce heading size */
    h2 { font-size: 1.2em; }
    #tagInput, #entryInput, #searchInput, #entryFilterInput {
     font-size: 0.95rem; /* Slightly smaller input text */
     padding: var(--spacing-sm) var(--spacing-md);
 }
 button, .file-io label.button-like {
     padding: var(--spacing-sm) var(--spacing-md); /* Slightly smaller buttons */
     font-size: 0.9rem;
 }
 .action-button-row { justify-content: center; } /* Center buttons */
 #tagDisplayArea span.tag-item { font-size: 0.9rem; } /* Slightly smaller tags */
 .current-entries-section { margin-top: var(--spacing-lg); }
 #currentEntriesDisplayArea { max-height: 180px; } /* Reduce max height */
 .file-io button {
     flex-basis: 100%; /* Stack file buttons */
 }
}

@media (max-width: 480px) {
    body { padding: var(--spacing-sm); } /* Minimum body padding */
    .container { padding: var(--spacing-md); } /* Minimum container padding */
    h1 { font-size: 1.5em; } /* Further reduce main heading */
    h2 { font-size: 1.1em; } /* Further reduce section headings */
    .left-column, .right-column { min-width: unset; } /* Allow columns to shrink fully */
    #tagInput, #entryInput, #searchInput, #entryFilterInput {
        font-size: 0.9rem; /* Smallest input font */
        padding: var(--spacing-xs) var(--spacing-sm); /* Smallest input padding */
    }
    #currentFileNameDisplay { font-size: 0.65em; } /* Smallest filename */

    /* Stack main action buttons vertically */
    .action-button-row {
        flex-direction: column; /* Stack buttons */
        align-items: stretch; /* Make buttons full width */
        gap: var(--spacing-sm); /* Adjust gap for vertical */
    }
    .action-button-row > button {
        width: 100%; /* Ensure full width */
        margin-bottom: 0; /* Reset bottom margin if any */
    }

    .file-io {
        justify-content: stretch;
        padding: var(--spacing-lg); /* Adjust padding */
        gap: var(--spacing-md); /* Adjust gap */
    }
    .file-io button { flex-grow: 1; width: 100%; } /* Ensure full width */

    #tagActionsArea .action-section .entry-input-wrapper { flex-direction: column; }
    #tagActionsArea .action-section .entry-input-wrapper input { width: 100%; }
    #tagActionsArea .action-section .action-buttons { flex-direction: column; align-items: stretch; }
    #tagActionsArea .action-section .action-buttons button { width: 100%; }

    #tagAreaInitialPlaceholder svg { width: 48px; height: 48px; }
    #tagAreaInitialPlaceholder span { margin-bottom: var(--spacing-lg); max-width: 90%; } /* Limit text width */
    #tagAreaInitialPlaceholder .placeholder-actions button { font-size: 0.85em;}

    #tagDisplayContainer { min-height: 120px; } /* Reduce min height */
    #tagDisplayArea {
     min-height: 80px; /* Reduce min height */
     padding: var(--spacing-md); /* Adjust padding */
     gap: var(--spacing-xs); /* Reduce gap */
 }
 #tagDisplayArea span.tag-item {
     padding: var(--spacing-xs) var(--spacing-sm); /* Smaller tags */
     font-size: 0.85rem;
 }
 .tag-entry-count { /* Adjust badge size/pos slightly if needed */
     min-width: 16px; height: 16px; font-size: 0.7em; margin-left: var(--spacing-xs);
 }

 .dark-mode-toggle span { display: none; } /* Keep icon only */
 .dark-mode-toggle { padding: var(--spacing-sm); }

 .filter-area { gap: var(--spacing-md); }
 .filter-group label { font-size: 0.85em; }

 #tagCountDisplay { text-align: center; font-size: 0.8em; padding: var(--spacing-sm) var(--spacing-sm); }

 #currentEntriesDisplayArea {
    max-height: 120px; /* Smallest max height */
    padding: var(--spacing-sm);
    gap: var(--spacing-xs);
}
#currentEntriesDisplayArea span.current-entry-item {
 padding: var(--spacing-xs) var(--spacing-sm);
 font-size: 0.8rem;
}
.current-entries-section h2 { text-align: center; }
#currentEntriesCountDisplay { text-align: center; font-size: 0.75em; padding: var(--spacing-xs) 0; }

footer { font-size: 0.8em; } /* Smaller footer text */
}

/* START: Menu CSS */
/* --- Menu Bar Styles --- */
#main-menu {
    display: flex;
    background-color: var(--color-bg-action-area); /* Match action area */
    padding: var(--spacing-xs) var(--spacing-md);
    border-bottom: 1px solid var(--color-border-divider);
    position: sticky; /* Keep it visible when scrolling */
    top: 0;
    z-index: 1001; /* Above other content but below modals maybe */
    box-shadow: var(--shadow-small);
    gap: var(--spacing-xs);
}

.menu-group {
    position: relative; /* For dropdown positioning */
}

button.menu-toggle {
    background: none;
    border: none;
    padding: var(--spacing-sm) var(--spacing-md);
    cursor: pointer;
    color: var(--color-text-primary);
    font-weight: 500;
    border-radius: var(--radius-small);
    transition: background-color var(--transition-fast);
}

button.menu-toggle:hover,
button.menu-toggle[aria-expanded="true"] {
    background-color: var(--color-bg-tag-hover);
}

body.dark-mode button.menu-toggle:hover,
body.dark-mode button.menu-toggle[aria-expanded="true"] {
    background-color: var(--color-bg-tag-hover);
}


.menu-dropdown {
    display: none; /* Hidden by default */
    position: absolute;
    top: 100%; /* Position below the toggle button */
    left: 0;
    background-color: var(--color-bg-suggestions); /* Match suggestions */
    border: 1px solid var(--color-border-suggestions);
    border-radius: var(--radius-medium);
    box-shadow: var(--shadow-suggestions);
    padding: var(--spacing-xs) 0;
    margin: 2px 0 0 0;
    list-style: none;
    z-index: 1002; /* Above menu bar */
    min-width: 200px; /* Ensure decent width */
    white-space: nowrap;
}

.menu-dropdown[aria-hidden="false"] {
    display: block; /* Show when expanded */
}

.menu-dropdown li {
    margin: 0;
    padding: 0;
}

.menu-dropdown hr {
    border: none;
    border-top: 1px solid var(--color-border-divider);
    margin: var(--spacing-xs) 0;
}

.menu-dropdown button[role="menuitem"] {
    display: flex; /* Use flex for icon alignment */
    align-items: center;
    gap: var(--spacing-md); /* Space between icon and text */
    background: none;
    border: none;
    width: 100%;
    text-align: left;
    padding: var(--spacing-sm) var(--spacing-lg);
    color: var(--color-text-primary);
    cursor: pointer;
    font-size: 0.9rem;
    transition: background-color var(--transition-fast);
}

/* Corrected Rule: Targets the span with the specific class */
.menu-dropdown button[role="menuitem"] > span.menu-item-label {
    flex-grow: 1; /* Ensures the label takes available space */
}

.menu-dropdown button[role="menuitem"] svg {
    width: 1em;
    height: 1em;
    flex-shrink: 0; /* Prevent icon shrinking */
    opacity: 0.8;
}

.menu-dropdown button[role="menuitem"]:hover:not([aria-disabled="true"]) {
    background-color: var(--color-bg-suggestion-hover);
    color: var(--color-text-link);
}

.menu-dropdown button[role="menuitem"]:focus-visible {
 outline: 2px solid var(--color-border-input-focus);
 outline-offset: -2px; /* Inside padding */
 background-color: var(--color-bg-suggestion-active);
 color: var(--color-text-link);
 box-shadow: none;
}


.menu-dropdown button[role="menuitem"][aria-disabled="true"] {
    color: var(--color-text-placeholder);
    cursor: not-allowed;
    opacity: 0.6;
}
/* Add class for styling if needed, though aria is primary */
.menu-dropdown button[role="menuitem"].disabled {
    /* Example: You could add specific visual styles here */
    /* opacity: 0.5; */
}

.menu-dropdown .shortcut {
    margin-left: auto; /* Push shortcut text to the right */
    padding-left: var(--spacing-xl);
    font-size: 0.8em;
    color: var(--color-text-secondary);
    opacity: 0.8;
}

/* Mobile Menu Toggle Button */
#mobile-menu-toggle {
    display: none !important; /* Hidden by default */
    position: fixed !important;
    top: var(--spacing-xl) !important; /* Keep consistent padding from top */
    left: var(--spacing-xl) !important; /* POSITION: Move to left */
    right: auto !important; /* Ensure right doesn't interfere */
    bottom: auto !important; /* Ensure bottom doesn't interfere */
    transform: none !important; /* Reset any transform */
    z-index: 1011 !important; /* Stacking order */
    background-color: var(--color-bg-tag);
    color: var(--color-text-primary);
    border: 1px solid var(--color-border-default);
    border-radius: var(--radius-medium);
    padding: var(--spacing-sm) var(--spacing-md); /* Match dark mode toggle padding */
    cursor: pointer;
    transition: background-color var(--transition-fast), color var(--transition-default), border-color var(--transition-default);
    line-height: 0;
}

#mobile-menu-toggle:hover {
    background-color: var(--color-bg-tag-hover);
}

#mobile-menu-toggle svg {
    width: 1.2em; /* Match dark mode toggle icon size */
    height: 1.2em; /* Match dark mode toggle icon size */
    vertical-align: middle;
    fill: currentColor;
}


/* --- Menu Responsive Adjustments --- */
@media (max-width: 768px) { /* Adjust breakpoint as needed */
    #main-menu {
        display: none; /* Hide desktop menu */
        position: fixed; /* Make it an overlay */
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5); /* Dim background */
        flex-direction: column;
        padding: var(--spacing-xl);
        overflow-y: auto; /* Allow scrolling if content overflows */
        box-shadow: none;
        border-bottom: none;
        align-items: flex-start; /* Align items to the start */
        z-index: 1010; /* Ensure it's on top (but below toggle) */
    }

    /* Style for dark mode overlay */
    body.dark-mode #main-menu {
        background-color: rgba(30, 30, 30, 0.8); /* Darker overlay */
    }

    #main-menu.mobile-visible {
        display: flex; /* Show when toggled */
    }

    #main-menu .menu-group {
        position: static; /* Reset positioning */
        width: 100%;
        margin-bottom: var(--spacing-lg);
    }

    #main-menu button.menu-toggle {
        font-size: 1.1em;
        font-weight: 600;
        width: 100%;
        text-align: left;
        background-color: transparent; /* Clearer background */
        color: var(--color-text-primary); /* Ensure visibility on overlay */
        /* Override text color on dark overlay */
        body.dark-mode & { color: var(--color-text-primary); }
        padding: var(--spacing-md) 0; /* Adjust padding */
        border-bottom: 1px solid var(--color-border-divider); /* Separator */
        body.dark-mode & { border-bottom-color: var(--color-border-divider); }
        margin-bottom: var(--spacing-sm);
    }
    body.dark-mode #main-menu button.menu-toggle {
        color: var(--color-text-primary); /* Re-apply just in case */
        border-bottom-color: var(--color-border-divider);
    }

    #main-menu button.menu-toggle[aria-expanded="true"] {
        background-color: transparent; /* No hover effect needed */
    }

    #main-menu .menu-dropdown {
        display: block; /* Always show dropdown content in mobile view */
        position: static; /* Reset positioning */
        border: none;
        box-shadow: none;
        background-color: transparent;
        padding: 0;
        margin: 0;
        width: 100%;
    }

    #main-menu .menu-dropdown button[role="menuitem"] {
        padding: var(--spacing-md) var(--spacing-sm); /* Adjust padding */
        color: var(--color-text-primary); /* Visibility on overlay */
        body.dark-mode & { color: var(--color-text-primary); }
        font-size: 1rem;
    }
    body.dark-mode #main-menu .menu-dropdown button[role="menuitem"] {
     color: var(--color-text-primary); /* Re-apply just in case */
 }

 #main-menu .menu-dropdown button[role="menuitem"]:hover {
     background-color: var(--color-bg-suggestion-hover); /* Keep hover effect */
     color: var(--color-text-link);
 }
 body.dark-mode #main-menu .menu-dropdown button[role="menuitem"]:hover {
     background-color: var(--color-bg-suggestion-hover);
     color: var(--color-text-link);
 }

 #main-menu .menu-dropdown button[role="menuitem"] .shortcut {
    display: none; /* Hide shortcuts on mobile */
}

#mobile-menu-toggle {
    display: block !important; /* Show hamburger button */
}

/* Adjust Dark Mode Toggle position slightly to avoid overlap */
.dark-mode-toggle {
}
body.menu-open {
    overflow: hidden; /* Prevent body scroll when mobile menu is open */
}

}
/* Smaller adjustments for very small screens if needed */
@media (max-width: 480px) {
 #mobile-menu-toggle {
 }
 .dark-mode-toggle {
    top: var(--spacing-md);
    right: var(--spacing-md);
}
}
/* END: Menu CSS */

.footer-note {
    margin-top: var(--spacing-lg);
    font-size: 0.8em;
    color: var(--color-text-placeholder);
    max-width: 600px; /* Optional: limit width */
    margin-left: auto;
    margin-right: auto;
}

</style>
</head>
<body>

<!-- Hamburger button for mobile -->
<button id="mobile-menu-toggle" aria-label="Toggle menu" aria-haspopup="true" aria-expanded="false">
    <svg viewBox="0 0 100 80"> <!-- Removed width and height attributes -->
      <rect width="100" height="15" rx="8"></rect>
      <rect y="30" width="100" height="15" rx="8"></rect>
      <rect y="60" width="100" height="15" rx="8"></rect>
  </svg>
</button>
<!-- END: Menu HTML -->

<!-- Feather Icons -->
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></symbol>
    <symbol id="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></symbol>
    <symbol id="icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></symbol>
    <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></symbol>
    <symbol id="icon-edit-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></symbol>
    <symbol id="icon-x" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></symbol>
    <symbol id="icon-save" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></symbol>
    <symbol id="icon-folder-open" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 18h13a1 1 0 0 0 1-1v-8.17a1.001 1.001 0 0 0-.29-.7l-3.55-3.56a.997.997 0 0 0-.71-.27H8.5a1 1 0 0 0-.99.87L6.97 7"></path><path d="M4 8h16v11a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1z"></path></symbol>
    <symbol id="icon-copy" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></symbol>
    <symbol id="icon-trash-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></symbol>
    <symbol id="icon-sort-az" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 18h6"/><path d="m19 21-4-4 4-4"/><path d="M3 6h12"/><path d="M3 12h9"/><path d="M15 4v17"/></symbol>
    <symbol id="icon-undo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></symbol>
    <symbol id="icon-redo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 0 9 9 9 9 0 0 0 6-2.3L21 13"/></symbol>
    <symbol id="icon-alert-circle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></symbol>
    <symbol id="icon-plus-circle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></symbol>
    <symbol id="icon-list" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></symbol>
    <symbol id="icon-file" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></symbol>  <symbol id="icon-maximize-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></symbol>
    <symbol id="icon-minimize-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line></symbol><symbol id="icon-git-merge" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path></symbol>
    <symbol id="icon-maximize-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></symbol>
</svg>

<button class="dark-mode-toggle" id="darkModeToggle" title="Toggle Color Theme">
    <svg class="light-icon" aria-hidden="true"><use href="#icon-moon"></use></svg>
    <svg class="dark-icon" aria-hidden="true"><use href="#icon-sun"></use></svg>
    <span>Theme</span>
</button>

<div class="container" data-dropzone="true">


    <h1>
        <span class="title-text">KeyWordManager-V1.4.6</span> <!-- Updated Version -->
        <span id="currentFileNameDisplay" title="Current file">Untitled</span>
    </h1>

<!-- START: Menu HTML -->
<nav id="main-menu" role="menubar" aria-label="Main menu">
    <div class="menu-group">
        <button class="menu-toggle" role="menuitem" aria-haspopup="true" aria-expanded="false" data-controls="file-menu-dropdown">File</button>
        <ul class="menu-dropdown" id="file-menu-dropdown" role="menu" aria-labelledby="file-menu-toggle">
            <li><button role="menuitem" id="menu-open" data-action="openFile"><svg><use href="#icon-folder-open"></use></svg><span class="menu-item-label">Open File...</span><span class="shortcut">Ctrl+O</span></button></li>
            <li><button role="menuitem" id="menu-save" data-action="saveFile"><svg><use href="#icon-save"></use></svg><span class="menu-item-label">Save</span><span class="shortcut">Ctrl+S</span></button></li>
            <li><button role="menuitem" id="menu-save-as" data-action="saveAsFile"><svg><use href="#icon-save"></use></svg><span class="menu-item-label">Save As...</span><span class="shortcut">Ctrl+Shift+S</span></button></li>
            <li><hr role="separator"></li>
            <li><button role="menuitem" id="menu-close" data-action="closeFile"><svg><use href="#icon-x"></use></svg><span class="menu-item-label">Close Current File</span></button></li>
            <!-- Add New/Exit later if needed -->
        </ul>
    </div>
    <div class="menu-group">
        <button class="menu-toggle" role="menuitem" aria-haspopup="true" aria-expanded="false" data-controls="edit-menu-dropdown">Edit</button>
        <ul class="menu-dropdown" id="edit-menu-dropdown" role="menu" aria-labelledby="edit-menu-toggle">
            <li><button role="menuitem" id="menu-undo" data-action="undo"><svg><use href="#icon-undo"></use></svg><span class="menu-item-label">Undo</span><span class="shortcut">Ctrl+Z</span></button></li>
            <li><button role="menuitem" id="menu-redo" data-action="redo"><svg><use href="#icon-redo"></use></svg><span class="menu-item-label">Redo</span><span class="shortcut">Ctrl+Y</span></button></li>
            <li><hr role="separator"></li>
            <!-- AFTER -->
            <li><button role="menuitem" id="menu-copy" data-action="copyTags"><svg><use href="#icon-copy"></use></svg><span class="menu-item-label">Copy Selected Tags</span><span class="shortcut">Ctrl+C</span></button></li>
            <li><button role="menuitem" id="menu-remove" data-action="removeTags"><svg><use href="#icon-trash-2"></use></svg><span class="menu-item-label">Remove Selected Tags</span><span class="shortcut">Del/Bksp</span></button></li><li><button role="menuitem" id="menu-combine" data-action="combineTags"><svg><use href="#icon-git-merge"></use></svg><span class="menu-item-label">Combine Selected Tags...</span></button></li>
            <li><hr role="separator"></li>
            <li><button role="menuitem" id="menu-select-all" data-action="selectAllTags"><svg><use href="#icon-list"></use></svg><span class="menu-item-label">Select All Tags</span><span class="shortcut">Ctrl+A</span></button></li>
            <!-- Add Find/Filter later if needed -->
        </ul>
    </div>
    <div class="menu-group">
        <button class="menu-toggle" role="menuitem" aria-haspopup="true" aria-expanded="false" data-controls="view-menu-dropdown">View</button>
        <ul class="menu-dropdown" id="view-menu-dropdown" role="menu" aria-labelledby="view-menu-toggle">
            <li><button role="menuitem" id="menu-sort" data-action="sortTags"><svg><use href="#icon-sort-az"></use></svg><span class="menu-item-label">Sort Tags (A-Z)</span></button></li>
            <li><hr role="separator"></li>
            <li><button role="menuitem" id="menu-theme" data-action="toggleTheme"><svg class="light-icon" aria-hidden="true"><use href="#icon-moon"></use></svg><svg class="dark-icon" aria-hidden="true"><use href="#icon-sun"></use></svg><span class="menu-item-label">Toggle Theme</span></button></li>
        </ul>
    </div>
    <div class="menu-group">
        <button class="menu-toggle" role="menuitem" aria-haspopup="true" aria-expanded="false" data-controls="help-menu-dropdown">Help</button>
        <ul class="menu-dropdown" id="help-menu-dropdown" role="menu" aria-labelledby="help-menu-toggle">
         <li><button role="menuitem" id="menu-about" data-action="showAbout"><svg><use href="#icon-alert-circle"></use></svg><span class="menu-item-label">About KeyWordManager</span></button></li>
         <!-- Add View Shortcuts later if needed -->
     </ul>
 </div>
</nav>
<!-- END: Menu HTML -->

<div class="main-layout">

    <div class="left-column">
        <!-- Input Area -->
        <div class="input-area">
            <!-- Wrapper for input + suggestions -->
            <div class="input-wrapper">
                <input type="text" id="tagInput" placeholder="Enter new tag(s), comma-separated"
                autocomplete="off" autocapitalize="none" spellcheck="false"
                aria-controls="tagSuggestions" aria-haspopup="listbox" aria-expanded="false">
                <ul class="suggestions-container" id="tagSuggestions" role="listbox"></ul>
            </div>
            <input type="text" id="entryInput" placeholder="Associated entries (optional, comma-separated)">
            <div> <!-- Button wrapper -->
                <button id="updateTagBtn" data-variant="primary" title="Save changes to the selected tag name" style="display: none;">
                    <svg aria-hidden="true"><use href="#icon-save"></use></svg> Update Tag Name
                </button>
                <button id="cancelUpdateBtn" data-variant="default" title="Cancel editing tag name" style="display: none;">
                    <svg aria-hidden="true"><use href="#icon-x"></use></svg> Cancel
                </button>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-button-row"> <button id="addTagBtn" data-variant="primary" title="Add the tag(s) and associated entries from inputs above"> <svg aria-hidden="true"><use href="#icon-plus"></use></svg> Add Tags </button> <button id="sortTagsBtn" data-variant="default" title="Sort tags alphabetically (A-Z)"> <svg aria-hidden="true"><use href="#icon-sort-az"></use></svg> Sort </button> <button id="copySelectedTagsBtn" data-variant="secondary" disabled title="Select tags to enable copying"> <svg aria-hidden="true"><use href="#icon-copy"></use></svg> Copy Selected </button> <button id="removeSelectedTagsBtn" data-variant="danger" disabled title="Select tags to enable removal"> <svg aria-hidden="true"><use href="#icon-trash-2"></use></svg> Remove Selected </button>
        </div>

        <!-- Message Area -->
        <div id="messageArea" class="message" role="alert" aria-live="polite"></div>

        <!-- Tag Actions (when 1 tag selected) -->
        <div id="tagActionsArea" aria-hidden="true"> <!-- Content dynamically generated by JS --> </div>

        <!-- Tag Display Heading & Controls -->
        <div class="section-header">
            <h2> <svg aria-hidden="true" style="width: 1em; height: 1em; vertical-align: -0.125em;"><use href="#icon-list"></use></svg> Current Tags </h2>
            <button id="fitTagsBtn" class="fit-button" data-target-area="tagDisplayArea" title="Fit tag area to screen height">
                <svg><use href="#icon-maximize-2"></use></svg>
                <span>Fit</span>
            </button>
        </div>

        <!-- Tag Display Container -->
        <div id="tagDisplayContainer">
         <!-- Initial Placeholder -->
         <div id="tagAreaInitialPlaceholder"> <svg aria-hidden="true"><use href="#icon-tag"></use></svg> <span>Add tags using the input above, or open/drop a .json file.</span> <div class="placeholder-actions"> <button id="addFirstTagBtn" data-variant="primary" title="Focus the 'Enter new tag(s)' input"> <svg aria-hidden="true"><use href="#icon-plus-circle"></use></svg> Add First Tag </button> <button id="openFilePlaceholderBtn" data-variant="default" title="Open a .json tag file"> <svg aria-hidden="true"><use href="#icon-file"></use></svg> Open File </button> </div> </div>
         <!-- Tag Display Area (Actual Tags) -->
         <div id="tagDisplayArea" role="listbox" aria-multiselectable="true" aria-label="Selectable tags list" tabindex="0">
             <!-- Placeholder for 'no results' (managed by JS) -->
             <span class="placeholder-text" id="tagAreaPlaceholder"> <svg aria-hidden="true"><use href="#icon-alert-circle"></use></svg> <span>No tags match the current filters.</span> </span>
             <!-- Tags will be rendered here by JS -->
             <!-- Tooltip placeholders (managed by JS) -->
             <div class="tag-tooltip"></div>
         </div>
     </div> <!-- End Tag Display Container -->

     <!-- Tag Count Display -->
     <div id="tagCountDisplay" aria-live="polite"> 0 tags total. 0 selected. </div>

     <!-- End Left Column -->
 </div> <!-- Closing tag for left-column -->

 <div class="right-column">
<!-- Search & Filter Area -->
<div class="filter-area">
 <div class="filter-group input-wrapper"> <!-- Wrapper -->
     <label for="searchInput">Search Tags:</label>
     <input type="search" id="searchInput" placeholder="Type to filter tags by name..."
     autocomplete="off" autocapitalize="none" spellcheck="false"
     aria-controls="searchSuggestions" aria-haspopup="listbox" aria-expanded="false">
     <ul class="suggestions-container" id="searchSuggestions" role="listbox"></ul> <!-- Suggestions -->
     <button id="clearSearchBtn" title="Clear search" aria-label="Clear search">&times;</button>
 </div>
 <div class="filter-group">
     <label for="entryFilterInput">Filter by Associated Entry:</label>
     <input type="search" id="entryFilterInput" placeholder="Type or click an entry below..." autocomplete="off">
     <button id="clearEntryFilterBtn" title="Clear entry filter" aria-label="Clear entry filter">&times;</button>
 </div>
</div>


<!-- Associated Entries now here -->
<div class="current-entries-section">
    <div class="section-header">
     <h2> <svg aria-hidden="true" style="width: 1em; height: 1em; vertical-align: -0.125em;"><use href="#icon-list"></use></svg> Associated Entries </h2>
     <button id="fitEntriesBtn" class="fit-button" data-target-area="currentEntriesDisplayArea" title="Fit entries area to screen height">
         <svg><use href="#icon-maximize-2"></use></svg>
         <span>Fit</span>
     </button>
 </div>
 <div id="currentEntriesDisplayArea">
    <!-- Placeholder for empty state (managed by JS) -->
    <span class="placeholder-text" id="currentEntriesPlaceholder"> <svg aria-hidden="true"><use href="#icon-alert-circle"></use></svg> <span>No associated entries found.</span> </span>
    <!-- Tooltip placeholders (managed by JS) -->
    <div class="entry-tooltip"></div>
</div>
<div id="currentEntriesCountDisplay"> 0 total entries. </div>
</div>

</div><!-- End Right Column -->

</div> <!-- End Main Layout -->

<!-- Footer -->
<footer>
    <p>Created by Maya as a part of organizing Maya's <a href="https://youtube.com/playlist?list=PLaeEzu3g112nopxGpaRNLKir-FYkspaIh&si=ic0lnTiezQSlvezk" target="_blank" rel="noopener noreferrer">OBE Journal entries.</a></p>
    <p class="footer-note"><small>Note: File operations require browser support for the File System Access API. Changes marked with '*' are unsaved. Without API support, unsaved changes are backed up per-file in browser storage.</small></p>
</footer>

</div> <!-- End Container -->

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Element References ---
        const container = document.querySelector('.container[data-dropzone="true"]');
        const tagInput = document.getElementById('tagInput');
        const entryInput = document.getElementById('entryInput');
        const addTagBtn = document.getElementById('addTagBtn');
        const updateTagBtn = document.getElementById('updateTagBtn');
        const cancelUpdateBtn = document.getElementById('cancelUpdateBtn');
        const sortTagsBtn = document.getElementById('sortTagsBtn');
        const copySelectedTagsBtn = document.getElementById('copySelectedTagsBtn');
        const removeSelectedTagsBtn = document.getElementById('removeSelectedTagsBtn');
        const tagDisplayContainer = document.getElementById('tagDisplayContainer');
        const tagAreaInitialPlaceholder = document.getElementById('tagAreaInitialPlaceholder');
        const addFirstTagBtn = document.getElementById('addFirstTagBtn');
        const openFilePlaceholderBtn = document.getElementById('openFilePlaceholderBtn'); // Keep placeholder button reference
        const tagDisplayArea = document.getElementById('tagDisplayArea');
        const tagAreaPlaceholder = document.getElementById('tagAreaPlaceholder');
        const tagActionsArea = document.getElementById('tagActionsArea');
        const messageArea = document.getElementById('messageArea');
        const currentFileNameDisplay = document.getElementById('currentFileNameDisplay');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const searchInput = document.getElementById('searchInput');
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        const entryFilterInput = document.getElementById('entryFilterInput');
        const clearEntryFilterBtn = document.getElementById('clearEntryFilterBtn');
        const tagCountDisplay = document.getElementById('tagCountDisplay');
        const currentEntriesDisplayArea = document.getElementById('currentEntriesDisplayArea');
        const currentEntriesPlaceholder = document.getElementById('currentEntriesPlaceholder');
        const currentEntriesCountDisplay = document.getElementById('currentEntriesCountDisplay');
        const tagSuggestions = document.getElementById('tagSuggestions');
        const searchSuggestions = document.getElementById('searchSuggestions');
        const tagTooltip = tagDisplayArea?.querySelector('.tag-tooltip');
        const entryTooltip = currentEntriesDisplayArea?.querySelector('.entry-tooltip');
        const fitTagsBtn = document.getElementById('fitTagsBtn');
        const fitEntriesBtn = document.getElementById('fitEntriesBtn');
        const footerElement = document.querySelector('footer');
        const combineSelectedTagsBtn = document.getElementById('combineSelectedTagsBtn');

        // --- Menu Element References ---
        const mainMenu = document.getElementById('main-menu');
        const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
        const menuToggles = document.querySelectorAll('#main-menu .menu-toggle');
        const menuItems = document.querySelectorAll('#main-menu [role="menuitem"]');

        // --- State Variables ---
        let tags = [];
        let tagBeingEditedValue = null;
        let currentFileHandle = null;
        let currentFileName = "Untitled";
        let hasUnsavedChanges = false;
        let currentSearchTerm = '';
        let currentEntryFilter = '';
        let activeEntryFilter = '';
        const localStorageKey = 'keywordTags_v6_refactor';
        const darkModeKey = 'darkModeEnabled_v2';
        let lastSelectedAnchorIndex = -1;
        let activeSuggestionIndex = -1;
        let currentSuggestionSource = null;
        let currentOpenMenu = null;

        // --- Undo/Redo State ---
        let history = [];
        let redoStack = [];
        const MAX_HISTORY_SIZE = 50;

        // --- API Support Check ---
        const supportsFileSystemAccess = 'showOpenFilePicker' in window;
        // No longer need to disable buttons here, menu state handles it.
        // Placeholder button logic is updated below.

        // --- Dark Mode ---
        const lightIcon = darkModeToggle?.querySelector('.light-icon'); const darkIcon = darkModeToggle?.querySelector('.dark-icon');
        function applyDarkModePreference() { const currentMode = localStorage.getItem(darkModeKey); if (currentMode === 'enabled') { document.body.classList.add('dark-mode'); } else { document.body.classList.remove('dark-mode'); } }
        function toggleDarkMode() { if (document.body.classList.contains('dark-mode')) { document.body.classList.remove('dark-mode'); localStorage.setItem(darkModeKey, 'disabled'); } else { document.body.classList.add('dark-mode'); localStorage.setItem(darkModeKey, 'enabled'); } applyDarkModePreference(); }
        applyDarkModePreference(); darkModeToggle?.addEventListener('click', toggleDarkMode);

        // --- UI Feedback ---
        function showMessage(text, type = 'success', duration = 3500) { if (!messageArea) return; messageArea.textContent = text; messageArea.className = 'message'; messageArea.classList.add(type); messageArea.setAttribute('role', type === 'error' ? 'alert' : 'status'); if (messageArea.timeoutId) clearTimeout(messageArea.timeoutId); messageArea.style.display = 'block'; requestAnimationFrame(() => { messageArea.classList.add('visible'); }); messageArea.timeoutId = setTimeout(() => { messageArea.classList.remove('visible'); messageArea.removeAttribute('role'); if (messageArea && !messageArea.classList.contains('visible')) { messageArea.style.display = 'none'; } }, duration); }

        function debounce(func, wait, immediate) {
            let timeout;
            return function() {
                const context = this, args = arguments;
                const later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };

        function toggleFitToScreen(buttonElement) {
            if (!buttonElement || !footerElement) return;
            const targetAreaId = buttonElement.dataset.targetArea;
            const targetArea = document.getElementById(targetAreaId);
            if (!targetArea) return;

            const isFitted = targetArea.classList.contains('is-fitted');
        const buffer = 30; // px buffer space above the footer

        if (isFitted) {
            // Resetting
            targetArea.style.height = null; // Remove inline style to revert to CSS/resized height
            targetArea.classList.remove('is-fitted');
            buttonElement.title = `Fit ${targetAreaId === 'tagDisplayArea' ? 'tag' : 'entries'} area to screen height`;
            buttonElement.innerHTML = `<svg><use href="#icon-maximize-2"></use></svg> <span>Fit</span>`;
            // Re-apply original resize capability (implicitly enabled when 'is-fitted' is removed if css is setup correctly)
            targetArea.style.resize = 'vertical'; // Explicitly ensure resize is back

        } else {
            // Fitting
            const rect = targetArea.getBoundingClientRect();
            const footerHeight = footerElement.offsetHeight;
            const availableHeight = window.innerHeight - rect.top - footerHeight - buffer;
            const minHeight = parseInt(window.getComputedStyle(targetArea).minHeight, 10) || 50; // Ensure min height from CSS

            targetArea.style.height = `${Math.max(availableHeight, minHeight)}px`;
            targetArea.classList.add('is-fitted');
            buttonElement.title = "Reset area size";
            buttonElement.innerHTML = `<svg><use href="#icon-minimize-2"></use></svg> <span>Reset</span>`;
             targetArea.style.resize = 'none'; // Explicitly disable resize
         }
     }

    // Debounced resize handler
     const handleResizeFit = debounce(() => {
        const fittedElements = document.querySelectorAll('.is-fitted');
        if (fittedElements.length > 0 && footerElement) {
         const buffer = 30;
         fittedElements.forEach(targetArea => {
             const rect = targetArea.getBoundingClientRect();
             const footerHeight = footerElement.offsetHeight;
             const availableHeight = window.innerHeight - rect.top - footerHeight - buffer;
             const minHeight = parseInt(window.getComputedStyle(targetArea).minHeight, 10) || 50;
             targetArea.style.height = `${Math.max(availableHeight, minHeight)}px`;
         });
     }
    }, 150); // Debounce time in ms


        // --- Menu Functions ---
     function closeAllMenus(exceptToggle = null) {
        menuToggles.forEach(toggle => { const dropdownId = toggle.getAttribute('data-controls'); const dropdown = document.getElementById(dropdownId); if (toggle !== exceptToggle && toggle.getAttribute('aria-expanded') === 'true') { toggle.setAttribute('aria-expanded', 'false'); if (dropdown) dropdown.setAttribute('aria-hidden', 'true'); } });
        currentOpenMenu = exceptToggle ? exceptToggle.getAttribute('data-controls') : null;
        if (mainMenu && window.innerWidth <= 768 && !document.body.classList.contains('menu-open')) { mainMenu.classList.remove('mobile-visible'); if(mobileMenuToggle) mobileMenuToggle.setAttribute('aria-expanded', 'false'); }
    }
    function toggleMenuDropdown(toggleButton) {
        if (!toggleButton) return; const expanded = toggleButton.getAttribute('aria-expanded') === 'true'; const dropdownId = toggleButton.getAttribute('data-controls'); const dropdown = document.getElementById(dropdownId);
        closeAllMenus(expanded ? null : toggleButton);
        if (!expanded) { toggleButton.setAttribute('aria-expanded', 'true'); if (dropdown) { dropdown.setAttribute('aria-hidden', 'false'); const firstItem = dropdown.querySelector('button[role="menuitem"]:not([aria-disabled="true"])'); firstItem?.focus(); } currentOpenMenu = dropdownId; }
    }
    function updateMenuItemStates() {
        if (!mainMenu || !tagDisplayArea) return;
        const selectedCount = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').length;
        const canUndo = history.length > 0 && tagBeingEditedValue === null;
        const canRedo = redoStack.length > 0 && tagBeingEditedValue === null;
        const canCopyRemove = selectedCount > 0 && tagBeingEditedValue === null;
        const canSave = hasUnsavedChanges && (supportsFileSystemAccess || currentFileName !== "Untitled") && tagBeingEditedValue === null;
        const canSaveAs = (supportsFileSystemAccess && tagBeingEditedValue === null);
        const canSort = tags.length > 1 && tagBeingEditedValue === null; const canCombine = selectedCount >= 2 && tagBeingEditedValue === null;
            // Removed: const canClear = tags.length > 0 && tagBeingEditedValue === null;
            const canClose = (tags.length > 0 || currentFileName !== 'Untitled') && tagBeingEditedValue === null; // Correct condition for closing
            const visibleTagItems = tagDisplayArea.querySelectorAll('span.tag-item').length > 0;
            const canSelectAll = tags.length > 0 && visibleTagItems && tagBeingEditedValue === null;
            const setState = (id, enabled) => { const item = document.getElementById(id); if (item) { item.setAttribute('aria-disabled', String(!enabled)); item.classList.toggle('disabled', !enabled); } };

            // Update menu item states
            setState('menu-save', canSave);
            setState('menu-save-as', canSaveAs);
            setState('menu-close', canClose); // Use menu-close and canClose condition
            // Removed: setState('menu-clear', canClear);
            setState('menu-undo', canUndo);
            setState('menu-redo', canRedo);
            setState('menu-copy', canCopyRemove);
            setState('menu-remove', canCopyRemove);
            setState('menu-select-all', canSelectAll);
            setState('menu-combine', canCombine);
            setState('menu-sort', canSort);
            setState('menu-open', tagBeingEditedValue === null && supportsFileSystemAccess);
            setState('menu-theme', true);
            setState('menu-about', true);

            // Update placeholder button state based on API support and edit mode
            if (openFilePlaceholderBtn) {
                openFilePlaceholderBtn.disabled = tagBeingEditedValue !== null || !supportsFileSystemAccess;
                openFilePlaceholderBtn.title = (!supportsFileSystemAccess) ? "Open File (disabled: requires File System Access API)" : (tagBeingEditedValue !== null) ? "Open File (disabled during edit)" : "Open a .json tag file";
            }
            // Ensure other placeholder buttons are handled if necessary
        }
        const menuActionMap = {
            openFile: openFile, saveFile: saveFile, saveAsFile: saveFileAs, closeFile: closeCurrentFile, undo: undo, redo: redo, copyTags: copySelectedTags, removeTags: removeSelectedTags, combineTags: combineTags,
            selectAllTags: () => { if (tagBeingEditedValue !== null) return; const visibleTags = getVisibleTagSpans(); if (visibleTags.length > 0) { visibleTags.forEach(span => { span.classList.add('selected'); span.setAttribute('aria-selected', 'true'); }); lastSelectedAnchorIndex = 0; updateMultiSelectActionButtons(); updateTagCountDisplay(); hideTagActions(false); if (visibleTags[0]) { const tagsList = getVisibleTagSpans(); tagsList.forEach(tag => tag.tabIndex = -1); visibleTags[0].tabIndex = 0; visibleTags[0].focus(); } showMessage(`Selected all ${visibleTags.length} visible tags.`, "info", 2000); } },
            sortTags: sortTags, toggleTheme: toggleDarkMode, showAbout: () => { alert(`KeyWordManager V1.4.6`); }
        };

        // --- Update Button States (includes menu state update) ---
        function updateMultiSelectActionButtons() {
           if (!copySelectedTagsBtn || !removeSelectedTagsBtn || !tagDisplayArea) return; const selectedCount = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').length; copySelectedTagsBtn.disabled = (selectedCount === 0 || tagBeingEditedValue !== null); copySelectedTagsBtn.title = (selectedCount === 0) ? "Select one or more tags to enable copying" : `Copy ${selectedCount} selected tag name(s) to clipboard`; removeSelectedTagsBtn.disabled = (selectedCount === 0 || tagBeingEditedValue !== null); removeSelectedTagsBtn.title = (selectedCount === 0) ? "Select tags to enable removal" : `Remove ${selectedCount} selected tag(s)`;
           if (combineSelectedTagsBtn) {
                combineSelectedTagsBtn.disabled = (selectedCount < 2 || tagBeingEditedValue !== null);
                combineSelectedTagsBtn.title = (selectedCount < 2) ? "Select 2 or more tags to enable combining" : `Combine ${selectedCount} selected tag(s)`;
            }           updateMenuItemStates();
       }
       function updateUndoRedoButtons() {
           updateMenuItemStates();
       }
       function updateFileNameDisplay() {
           if (!currentFileNameDisplay) return; currentFileNameDisplay.textContent = currentFileName; currentFileNameDisplay.title = `Current file: ${currentFileName}`; currentFileNameDisplay.classList.toggle('unsaved', hasUnsavedChanges);
           updateMenuItemStates();
       }

        // --- State Management Helpers ---
       function setUnsavedChanges(state) {
           if (hasUnsavedChanges !== state) { hasUnsavedChanges = state; updateFileNameDisplay(); if (state && !supportsFileSystemAccess && currentFileName !== "Untitled") { saveTagsToLocalStorage(); } }
       }
       async function confirmDiscardUnsaved() {
           if (!hasUnsavedChanges) return true;
           return new Promise((resolve) => {
               const confirmation = confirm(`You have unsaved changes in "${currentFileName}".\n\nDiscard changes?`);
               resolve(confirmation);
           });
       }


        // --- Data Persistence (Backup Logic) ---
       function getBackupKey(filename) { if (!filename || filename === "Untitled") return null; const sanitizedFilename = filename.replace(/[^a-zA-Z0-9._-]/g, '_'); return `${localStorageKey}_backup_${sanitizedFilename}`; }
       function saveTagsToLocalStorage() { if (supportsFileSystemAccess || currentFileName === "Untitled") return; const backupKey = getBackupKey(currentFileName); if (!backupKey) return; console.log(`Saving backup for "${currentFileName}" to LocalStorage key "${backupKey}"...`); try { const dataToStore = tags.map(tag => ({ value: tag.value, entries: tag.entries ?? [] })); localStorage.setItem(backupKey, JSON.stringify(dataToStore)); } catch (e) { console.error(`Error saving backup to localStorage for ${currentFileName}:`, e); showMessage(`Error saving backup for ${currentFileName} to browser storage.`, 'error'); } }
       function removeBackup(filename) { const backupKey = getBackupKey(filename); if (backupKey) { console.log(`Removing backup for "${filename}" (key: ${backupKey})`); localStorage.removeItem(backupKey); } }
       async function checkForAndHandleBackup(filename, originalParsedData) { const result = { dataToLoad: originalParsedData, backupLoaded: false, sourceName: filename }; if (supportsFileSystemAccess) { return result; } const backupKey = getBackupKey(filename); if (!backupKey) { return result; } try { const backupJson = localStorage.getItem(backupKey); if (backupJson) { console.log(`Found backup for "${filename}"`); let backupData; try { backupData = JSON.parse(backupJson); } catch (parseError) { throw new Error(`Invalid JSON format in backup for "${filename}".`); } const useBackup = confirm( `An unsaved backup was found for "${filename}".\n\n` + `Load the backup instead of the original file?\n\n` + `[OK = Load Backup] [Cancel = Load Original File]` ); if (useBackup) { result.dataToLoad = backupData; result.backupLoaded = true; result.sourceName = `${filename} (Backup)`; console.log(`User chose to load backup for "${filename}"`); showMessage(`Loaded unsaved backup for "${filename}". Changes are still marked as unsaved relative to the file.`, "info", 5000); } else { console.log(`User chose to load original file for "${filename}", ignoring backup.`); if (confirm(`Delete the unused backup for "${filename}"?\n\nThis cannot be undone.`)) { removeBackup(filename); showMessage(`Removed unused backup for "${filename}". Loading original file.`, "info", 3000); } else { showMessage(`Keeping backup for "${filename}". Loading original file.`, "info", 3000); } } } else { console.log(`No backup found for "${filename}"`); } } catch (error) { console.error(`Error checking/handling backup for ${filename}:`, error); showMessage(`Error checking backup for ${filename}: ${error.message}. Loading original file.`, 'error'); result.dataToLoad = originalParsedData; result.backupLoaded = false; result.sourceName = filename; } return result; }

        // --- State Reset/Finalization ---
       function resetStateBeforeLoad() { tags = []; history = []; redoStack = []; currentFileHandle = null; currentFileName = "Untitled"; hasUnsavedChanges = false; if(tagBeingEditedValue) cancelEdit(true); currentSearchTerm = ''; currentEntryFilter = ''; activeEntryFilter = ''; if(searchInput) searchInput.value = ''; if(entryFilterInput) entryFilterInput.value = ''; if(clearSearchBtn) clearSearchBtn.style.display = 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none'; lastSelectedAnchorIndex = -1; hideSuggestions(); }
       function finalizeLoad() {
           if (tags.length > 0) { tags.sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase())); }
           renderTags(); renderCurrentEntries(); hideTagActions(true); updateUndoRedoButtons(); updateFileNameDisplay(); updateMultiSelectActionButtons(); setInitialTagFocus(); updateTagCountDisplay(); hideSuggestions();
       }
       async function closeCurrentFile() {
        hideSuggestions();
        if (tagBeingEditedValue !== null) cancelEdit(true);

        if (!(await confirmDiscardUnsaved())) {
            showMessage("Close operation cancelled.", "info");
            return;
        }

                // Reset the entire state to initial
        resetStateBeforeLoad();
                finalizeLoad(); // This renders the empty state and updates UI

                showMessage("File closed. Editor reset to initial state.", "success");
            }


        // --- Undo/Redo Logic ---
            const deepCopy = (obj) => JSON.parse(JSON.stringify(obj));
            function saveStateForUndo(actionName = "action") { const callerFunction = saveStateForUndo.caller?.name; if (callerFunction === 'redo') { return; } redoStack = []; history.push({ state: deepCopy({ tags, currentSearchTerm, currentEntryFilter, activeEntryFilter }), name: actionName }); if (history.length > MAX_HISTORY_SIZE) { history.shift(); } updateUndoRedoButtons(); }
            function undo() {
               if (history.length === 0 || tagBeingEditedValue !== null) return; cancelEdit(true); hideSuggestions(); const currentState = deepCopy({ tags, currentSearchTerm, currentEntryFilter, activeEntryFilter }); const { state: previousFullState, name: actionName } = history.pop(); redoStack.push({ state: currentState, name: actionName }); tags = previousFullState.tags; currentSearchTerm = previousFullState.currentSearchTerm || ''; currentEntryFilter = previousFullState.currentEntryFilter || ''; activeEntryFilter = previousFullState.activeEntryFilter || ''; if (searchInput) searchInput.value = currentSearchTerm; if (entryFilterInput) entryFilterInput.value = currentEntryFilter; if(clearSearchBtn) clearSearchBtn.style.display = currentSearchTerm ? 'inline-block' : 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = (currentEntryFilter || activeEntryFilter) ? 'inline-block' : 'none';
               setUnsavedChanges(true); renderTags(); renderCurrentEntries(); hideTagActions(true); updateUndoRedoButtons(); updateMultiSelectActionButtons(); setInitialTagFocus(); updateTagCountDisplay(); lastSelectedAnchorIndex = -1; showMessage(`Undo: ${actionName}`, "info", 2000);
           }
           function redo() {
               if (redoStack.length === 0 || tagBeingEditedValue !== null) return; cancelEdit(true); hideSuggestions(); const currentState = deepCopy({ tags, currentSearchTerm, currentEntryFilter, activeEntryFilter }); const { state: nextFullState, name: actionName } = redoStack.pop(); history.push({ state: currentState, name: actionName }); tags = nextFullState.tags; currentSearchTerm = nextFullState.currentSearchTerm || ''; currentEntryFilter = nextFullState.currentEntryFilter || ''; activeEntryFilter = nextFullState.activeEntryFilter || ''; if (searchInput) searchInput.value = currentSearchTerm; if (entryFilterInput) entryFilterInput.value = currentEntryFilter; if(clearSearchBtn) clearSearchBtn.style.display = currentSearchTerm ? 'inline-block' : 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = (currentEntryFilter || activeEntryFilter) ? 'inline-block' : 'none';
               setUnsavedChanges(true); renderTags(); renderCurrentEntries(); hideTagActions(true); updateUndoRedoButtons(); updateMultiSelectActionButtons(); setInitialTagFocus(); updateTagCountDisplay(); lastSelectedAnchorIndex = -1; showMessage(`Redo: ${actionName}`, "info", 2000);
           }

        // --- Core Logic: Tag Finding ---
           function findTagObject(value) { if (!value) return null; const lowerCaseValue = value.toLowerCase(); return tags.find(tag => tag.value.toLowerCase() === lowerCaseValue) || null; }

        // --- Tooltip Position Helper ---
           function updateTooltipPosition(event, tooltipEl) { if (!tooltipEl) return; const x = event.clientX + 10; const y = event.clientY + 10; const maxX = window.innerWidth - tooltipEl.offsetWidth - 5; const maxY = window.innerHeight - tooltipEl.offsetHeight - 5; tooltipEl.style.left = `${Math.min(x, maxX)}px`; tooltipEl.style.top = `${Math.min(y, maxY)}px`; }

        // --- UI Logic: Actions and Selection ---
           function hideTagActions(clearSelection = true) { if (tagActionsArea) { tagActionsArea.classList.remove('visible'); tagActionsArea.setAttribute('aria-hidden', 'true'); setTimeout(() => { if (tagActionsArea && !tagActionsArea.classList.contains('visible')) { tagActionsArea.innerHTML = ''; } }, 300); } if (clearSelection && tagDisplayArea) { tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').forEach(span => { span.classList.remove('selected'); span.setAttribute('aria-selected', 'false'); }); lastSelectedAnchorIndex = -1; } if (tagBeingEditedValue === null) { resetInputAreaAppearance(); } updateMultiSelectActionButtons(); updateTagCountDisplay(); }
           function resetInputAreaAppearance() { if (tagInput) tagInput.placeholder = "Enter new tag(s), comma-separated"; if (addTagBtn) addTagBtn.style.display = 'inline-flex'; if (updateTagBtn) updateTagBtn.style.display = 'none'; if (cancelUpdateBtn) cancelUpdateBtn.style.display = 'none'; if (entryInput) entryInput.disabled = false; if (tagInput) tagInput.value = ''; if (entryInput) entryInput.value = ''; }
           function showTagActions(tagValue) { if (tagBeingEditedValue !== null || !tagActionsArea || !tagDisplayArea) return; const tagObject = findTagObject(tagValue); const visibleTagSpan = getVisibleTagSpan(tagValue); const selectedCount = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').length; if (!tagObject || !visibleTagSpan || selectedCount !== 1 || visibleTagSpan.getAttribute('aria-selected') !== 'true') { hideTagActions(false); return; } tagActionsArea.innerHTML = ''; try { if (!Array.isArray(tagObject.entries)) { tagObject.entries = []; tagObject.count = 0; } const coreDiv = document.createElement('div'); coreDiv.className = 'action-section'; coreDiv.innerHTML = `<label>Tag Actions:</label>`; const btnWrapper = document.createElement('div'); btnWrapper.className = 'action-buttons'; const editBtn = createActionButton('Edit Name', 'warning', 'edit-2', () => startEditTag(tagValue), `Edit name "${tagValue}"`); const removeBtn = createActionButton('Remove Tag', 'danger', 'trash-2', () => removeSingleTag(tagValue), `Remove tag "${tagValue}"`); btnWrapper.append(editBtn, removeBtn); coreDiv.appendChild(btnWrapper); tagActionsArea.appendChild(coreDiv); const entriesDiv = document.createElement('div'); entriesDiv.className = 'action-section'; entriesDiv.innerHTML = `<label for="actionEntryInput">Associated Entries (${tagObject.entries.length}):</label>`; const entryInputWrapper = document.createElement('div'); entryInputWrapper.className = 'entry-input-wrapper'; entryInputWrapper.style.display = 'flex'; entryInputWrapper.style.gap = 'var(--spacing-sm)'; const actionEntryInput = document.createElement('input'); actionEntryInput.type = 'text'; actionEntryInput.id = 'actionEntryInput'; actionEntryInput.placeholder = 'Add association(s)'; entryInputWrapper.appendChild(actionEntryInput); const addEntryBtn = createActionButton('Add', 'primary', 'plus', () => addDiaryEntry(tagValue, actionEntryInput.value), 'Add diary entry references (split by comma)', 'add-entry-btn'); entryInputWrapper.appendChild(addEntryBtn); entriesDiv.appendChild(entryInputWrapper); actionEntryInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { event.preventDefault(); addEntryBtn.click(); } }); const entriesListDiv = document.createElement('div'); entriesListDiv.className = 'entries-list'; renderEntriesList(entriesListDiv, tagObject, tagValue); entriesDiv.appendChild(entriesListDiv); tagActionsArea.appendChild(entriesDiv); } catch (e) { console.error("Error creating tag actions UI:", e); tagActionsArea.innerHTML = '<p class="message error">Error loading actions.</p>'; } tagActionsArea.style.display = 'block'; requestAnimationFrame(() => { tagActionsArea.classList.add('visible'); tagActionsArea.setAttribute('aria-hidden', 'false'); }); updateMultiSelectActionButtons(); updateTagCountDisplay(); }
           function createActionButton(text, variant, iconId, onClick, title, extraClass = 'action-btn') { const btn = document.createElement('button'); btn.className = extraClass; btn.dataset.variant = variant; btn.title = title; btn.onclick = onClick; btn.innerHTML = `<svg aria-hidden="true" focusable="false"><use href="#icon-${iconId}"></use></svg> <span>${text}</span>`; return btn; }
           function renderEntriesList(containerElement, tagObject, tagValue) { containerElement.innerHTML = ''; const currentEntries = tagObject.entries ?? []; if (currentEntries.length > 0) { const entriesWithOriginalIndex = currentEntries.map((entry, index) => ({ entry, originalIndex: index })); const getNum = (str) => parseInt(String(str).replace(/[^0-9]/g, ''), 10) || Infinity; entriesWithOriginalIndex.sort((a, b) => { const numA = getNum(a.entry); const numB = getNum(b.entry); return numA !== numB ? numA - numB : String(a.entry).localeCompare(String(b.entry)); }); entriesWithOriginalIndex.forEach(({ entry, originalIndex }) => { const entrySpan = document.createElement('span'); entrySpan.textContent = entry; const removeEntryBtn = document.createElement('button'); removeEntryBtn.innerHTML = '&times;'; removeEntryBtn.className = 'remove-entry-btn'; removeEntryBtn.title = `Remove entry "${entry}"`; removeEntryBtn.setAttribute('aria-label', `Remove entry ${entry}`); removeEntryBtn.onclick = (e) => { e.stopPropagation(); removeDiaryEntry(tagValue, originalIndex); }; entrySpan.appendChild(removeEntryBtn); containerElement.appendChild(entrySpan); }); } else { containerElement.innerHTML = `<em>No entries associated.</em>`; } }

        // --- UI Logic: Rendering Tags ---
           function renderTags() {
               if (!tagDisplayContainer || !tagAreaInitialPlaceholder || !tagDisplayArea || !tagAreaPlaceholder) { console.error("Missing critical tag display elements."); return; }
               if (tags.length === 0) { tagAreaInitialPlaceholder.classList.remove('hidden'); tagDisplayArea.classList.remove('visible'); tagDisplayArea.innerHTML = ''; tagDisplayArea.appendChild(tagAreaPlaceholder); if(tagTooltip) tagDisplayArea.appendChild(tagTooltip); tagAreaPlaceholder.classList.remove('visible'); lastSelectedAnchorIndex = -1; updateTagCountDisplay(); updateMenuItemStates(); return; }
               tagAreaInitialPlaceholder.classList.add('hidden'); tagDisplayArea.classList.add('visible'); tagAreaPlaceholder.classList.remove('visible');
               const searchTermLower = currentSearchTerm.toLowerCase(); const entryFilterToUse = activeEntryFilter ? activeEntryFilter.toLowerCase() : currentEntryFilter.toLowerCase(); const filteredTags = tags.filter(tag => { const nameMatch = !searchTermLower || tag.value.toLowerCase().includes(searchTermLower); const entryMatch = !entryFilterToUse || (Array.isArray(tag.entries) && tag.entries.some(entry => String(entry).toLowerCase().includes(entryFilterToUse))); return nameMatch && entryMatch; });
               const previouslySelectedValues = new Set( Array.from(tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]')).map(span => span.dataset.tagValue) ); const focusedTagElement = document.activeElement?.closest('.tag-item'); const focusedTagValue = focusedTagElement ? focusedTagElement.dataset.tagValue : null;
               tagDisplayArea.querySelectorAll('span.tag-item').forEach(el => el.remove());
               if (filteredTags.length === 0) { if (tagAreaPlaceholder.querySelector('span')) { let placeholderMsg = "No tags match the current filters."; if (searchTermLower && entryFilterToUse) { placeholderMsg = `No tags match search "${currentSearchTerm}" and entry filter "${activeEntryFilter || currentEntryFilter}".`; } else if (searchTermLower) { placeholderMsg = `No tags match search "${currentSearchTerm}".`; } else if (entryFilterToUse) { placeholderMsg = `No tags match entry filter "${activeEntryFilter || currentEntryFilter}".`; } tagAreaPlaceholder.querySelector('span').textContent = placeholderMsg; } tagAreaPlaceholder.classList.add('visible'); lastSelectedAnchorIndex = -1; }
               else { const sortedTagsForDisplay = [...filteredTags].sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase())); sortedTagsForDisplay.forEach((tagObj) => { if (!tagObj || typeof tagObj.value !== 'string') return; const tagSpan = document.createElement('span'); tagSpan.className = 'tag-item'; tagSpan.textContent = tagObj.value; tagSpan.setAttribute('role', 'option'); tagSpan.tabIndex = -1; tagSpan.dataset.tagValue = tagObj.value; const isSelected = previouslySelectedValues.has(tagObj.value); tagSpan.setAttribute('aria-selected', String(isSelected)); tagSpan.classList.toggle('selected', isSelected); tagObj.count = Array.isArray(tagObj.entries) ? tagObj.entries.length : 0; if (tagObj.count > 0) { const countBadge = document.createElement('span'); countBadge.className = 'tag-entry-count'; countBadge.textContent = tagObj.count; countBadge.title = `${tagObj.count} associated entr${tagObj.count === 1 ? 'y' : 'ies'}`; tagSpan.appendChild(countBadge); } let activeMoveHandler = null; let activeLeaveHandler = null; tagSpan.addEventListener('mouseenter', (e) => { if (tagTooltip && tagObj.count > 0) { if (activeMoveHandler) document.removeEventListener('mousemove', activeMoveHandler); if (activeLeaveHandler) tagSpan.removeEventListener('mouseleave', activeLeaveHandler); const entriesList = tagObj.entries.join(', '); tagTooltip.innerHTML = `<div><strong>Appears in ${tagObj.count} entr${tagObj.count === 1 ? 'y' : 'ies'}:</strong></div><div style="margin-top: 4px;">${entriesList}</div>`; tagTooltip.classList.add('visible'); activeMoveHandler = (moveEvent) => updateTooltipPosition(moveEvent, tagTooltip); activeLeaveHandler = () => { document.removeEventListener('mousemove', activeMoveHandler); tagSpan.removeEventListener('mouseleave', activeLeaveHandler); if (tagTooltip) tagTooltip.classList.remove('visible'); activeMoveHandler = null; activeLeaveHandler = null; }; activeMoveHandler(e); document.addEventListener('mousemove', activeMoveHandler); tagSpan.addEventListener('mouseleave', activeLeaveHandler); } }); tagSpan.addEventListener('click', (event) => { if (event.detail < 2) { event.stopPropagation(); if (tagBeingEditedValue !== null) return; handleTagSelection(tagSpan, event); } }); tagSpan.addEventListener('dblclick', (event) => { event.stopPropagation(); const tagValue = event.currentTarget.dataset.tagValue; if (tagValue) { startEditTag(tagValue); } }); tagDisplayArea.appendChild(tagSpan); }); }
               const newFocusElement = focusedTagValue ? getVisibleTagSpan(focusedTagValue) : null; setInitialTagFocus(newFocusElement ? focusedTagValue : null); updateAnchorIndex();
               const finalSelectedCount = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').length; if (finalSelectedCount === 1) { const singleSelectedValue = tagDisplayArea.querySelector('span.tag-item[aria-selected="true"]').dataset.tagValue; const actionPanelVisible = tagActionsArea?.classList.contains('visible'); const editBtnInPanel = tagActionsArea?.querySelector('button[title^="Edit name"]'); const actionPanelTag = actionPanelVisible && editBtnInPanel ? editBtnInPanel.title?.match(/Edit name "([^"]+)"/)?.[1] : null; if (!actionPanelVisible || actionPanelTag !== singleSelectedValue) { showTagActions(singleSelectedValue); } } else if (finalSelectedCount !== 1 && tagActionsArea?.classList.contains('visible')) { hideTagActions(false); } else { if (finalSelectedCount !== 1) hideTagActions(false); }
               updateMultiSelectActionButtons(); updateTagCountDisplay(); updateMenuItemStates();
           }

        // --- UI Logic: Render Associated Entries ---
           function renderCurrentEntries() { if (!currentEntriesDisplayArea || !currentEntriesPlaceholder || !currentEntriesCountDisplay || !entryTooltip) return; currentEntriesDisplayArea.querySelectorAll('.current-entry-item').forEach(el => el.remove()); currentEntriesPlaceholder.classList.remove('visible'); const entryTagMap = new Map(); tags.forEach(tag => { if (Array.isArray(tag.entries)) { tag.entries.forEach(entry => { const trimmedEntry = String(entry).trim().replace(/\s+/g, ' '); if (trimmedEntry) { if (!entryTagMap.has(trimmedEntry)) { entryTagMap.set(trimmedEntry, []); } entryTagMap.get(trimmedEntry).push(tag.value); } }); } }); const allUniqueEntries = Array.from(entryTagMap.keys()); if (allUniqueEntries.length === 0) { currentEntriesDisplayArea.appendChild(currentEntriesPlaceholder); currentEntriesPlaceholder.classList.add('visible'); currentEntriesCountDisplay.textContent = '0 total entries.'; return; } const getNum = (str) => parseInt(String(str).replace(/[^0-9]/g, ''), 10) || Infinity; allUniqueEntries.sort((a, b) => { const numA = getNum(a); const numB = getNum(b); return numA !== numB ? numA - numB : String(a).localeCompare(String(b)); }); allUniqueEntries.forEach(entry => { const entrySpan = document.createElement('span'); entrySpan.className = 'current-entry-item clickable'; entrySpan.textContent = entry; entrySpan.dataset.entryValue = entry; let entryMoveHandler = null; let entryLeaveHandler = null; entrySpan.addEventListener('mouseenter', (e) => { const tagsForEntry = entryTagMap.get(entry); if (entryTooltip && tagsForEntry && tagsForEntry.length > 0) { if (entryMoveHandler) document.removeEventListener('mousemove', entryMoveHandler); if (entryLeaveHandler) entrySpan.removeEventListener('mouseleave', entryLeaveHandler); entryTooltip.innerHTML = `<div><strong>Used by ${tagsForEntry.length} tag(s):</strong></div><div class="tooltip-content-wrap" style="margin-top: 4px;">${tagsForEntry.join(', ')}</div>`; entryTooltip.classList.add('visible'); entryMoveHandler = (moveEvent) => updateTooltipPosition(moveEvent, entryTooltip); entryLeaveHandler = () => { document.removeEventListener('mousemove', entryMoveHandler); entrySpan.removeEventListener('mouseleave', entryLeaveHandler); if(entryTooltip) entryTooltip.classList.remove('visible'); entryMoveHandler = null; entryLeaveHandler = null; }; entryMoveHandler(e); document.addEventListener('mousemove', entryMoveHandler); entrySpan.addEventListener('mouseleave', entryLeaveHandler); } }); entrySpan.onclick = handleEntryClick; if (entry === activeEntryFilter) { entrySpan.classList.add('active-filter'); } currentEntriesDisplayArea.appendChild(entrySpan); }); currentEntriesCountDisplay.textContent = `${allUniqueEntries.length} total entr${allUniqueEntries.length === 1 ? 'y' : 'ies'}.`; }
           function handleEntryClick(event) { if (tagBeingEditedValue !== null) return; const clickedValue = event.target.dataset.entryValue; if (!clickedValue) return; if (activeEntryFilter === clickedValue) { activeEntryFilter = ''; showMessage('Entry filter cleared.', 'info', 1500); } else { activeEntryFilter = clickedValue; } if (entryFilterInput) entryFilterInput.value = ''; currentEntryFilter = ''; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = activeEntryFilter ? 'inline-block' : 'none'; renderTags(); renderCurrentEntries(); }

        // --- Update Anchor Index ---
           function updateAnchorIndex() { const visibleTags = getVisibleTagSpans(); if (lastSelectedAnchorIndex === -1 || lastSelectedAnchorIndex >= visibleTags.length) { const firstSelectedIndex = visibleTags.findIndex(span => span.getAttribute('aria-selected') === 'true'); lastSelectedAnchorIndex = firstSelectedIndex >= 0 ? firstSelectedIndex : -1; } }
           function updateTagCountDisplay() { if (!tagCountDisplay || !tagDisplayArea) return; const totalVisibleTags = tagDisplayArea.querySelectorAll('span.tag-item').length; const totalSelectedTags = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').length; const totalTagsInState = tags.length; tagCountDisplay.textContent = `${totalTagsInState} tags total (${totalVisibleTags} visible). ${totalSelectedTags} selected.`; }
           function handleTagSelection(tagSpan, event) { if (!tagSpan || tagBeingEditedValue !== null) return; const isCtrlPressed = event.ctrlKey || event.metaKey; const isShiftPressed = event.shiftKey; const visibleTags = getVisibleTagSpans(); const clickedIndex = visibleTags.indexOf(tagSpan); if (clickedIndex === -1) return; if (isShiftPressed && visibleTags.length > 0) { let anchorIndex = lastSelectedAnchorIndex; if (anchorIndex === -1) { const firstSelectedIndex = visibleTags.findIndex(span => span.getAttribute('aria-selected') === 'true'); anchorIndex = firstSelectedIndex !== -1 ? firstSelectedIndex : 0; } const startIndex = Math.min(anchorIndex, clickedIndex); const endIndex = Math.max(anchorIndex, clickedIndex); visibleTags.forEach((span, index) => { const shouldBeSelected = (index >= startIndex && index <= endIndex); span.classList.toggle('selected', shouldBeSelected); span.setAttribute('aria-selected', String(shouldBeSelected)); }); } else if (isCtrlPressed) { const isSelected = tagSpan.getAttribute('aria-selected') === 'true'; tagSpan.classList.toggle('selected', !isSelected); tagSpan.setAttribute('aria-selected', String(!isSelected)); const totalSelected = visibleTags.filter(s => s.getAttribute('aria-selected') === 'true').length; if (totalSelected === 1 && !isSelected) { lastSelectedAnchorIndex = clickedIndex; } else if (totalSelected === 0) { lastSelectedAnchorIndex = -1; } } else { visibleTags.forEach((span, index) => { const shouldBeSelected = (index === clickedIndex); span.classList.toggle('selected', shouldBeSelected); span.setAttribute('aria-selected', String(shouldBeSelected)); }); lastSelectedAnchorIndex = clickedIndex; } const finalSelectedCount = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').length; if (finalSelectedCount === 1) { const selectedTagValue = tagDisplayArea.querySelector('span.tag-item[aria-selected="true"]').dataset.tagValue; showTagActions(selectedTagValue); } else { hideTagActions(false); } updateMultiSelectActionButtons(); updateTagCountDisplay(); setInitialTagFocus(tagSpan.dataset.tagValue); if (document.activeElement !== tagSpan) { tagSpan.focus(); } }

        // --- Keyboard Navigation for Tags ---
           function getVisibleTagSpans() { return Array.from(tagDisplayArea.querySelectorAll('span.tag-item')); }
           function getVisibleTagSpan(tagValue) { if (!tagValue) return null; try { return tagDisplayArea.querySelector(`span.tag-item[data-tag-value="${CSS.escape(tagValue)}"]`); } catch (e) { console.error("Error finding tag span:", tagValue, e); return null; } }
           function setInitialTagFocus(valueToFocus = null) { const tagsList = getVisibleTagSpans(); tagsList.forEach(tag => tag.tabIndex = -1); let tagToMakeFocusable = null; if (valueToFocus) { tagToMakeFocusable = getVisibleTagSpan(valueToFocus); } if (!tagToMakeFocusable && lastSelectedAnchorIndex >= 0 && lastSelectedAnchorIndex < tagsList.length) { tagToMakeFocusable = tagsList[lastSelectedAnchorIndex]; } if (!tagToMakeFocusable) { tagToMakeFocusable = tagsList.find(tag => tag.getAttribute('aria-selected') === 'true'); } if (!tagToMakeFocusable && tagsList.length > 0) { tagToMakeFocusable = tagsList[0]; } if (tagToMakeFocusable) { tagToMakeFocusable.tabIndex = 0; tagDisplayArea.tabIndex = -1; } else if (tagsList.length === 0 && tagDisplayArea.classList.contains('visible')) { tagDisplayArea.tabIndex = 0; } else if (tags.length === 0 && !tagAreaInitialPlaceholder.classList.contains('hidden')) { tagDisplayArea.tabIndex = 0; } else { tagDisplayArea.tabIndex = 0; } }
           tagDisplayArea.addEventListener('keydown', (e) => { if (tagBeingEditedValue !== null) return; const tagsList = getVisibleTagSpans(); if (tagsList.length === 0) return; const isCtrl = e.ctrlKey || e.metaKey; const isShift = e.shiftKey; let currentFocusedIndex = tagsList.findIndex(tag => tag === document.activeElement || tag.tabIndex === 0); if (currentFocusedIndex === -1 && document.activeElement === tagDisplayArea) { currentFocusedIndex = lastSelectedAnchorIndex !== -1 ? lastSelectedAnchorIndex : 0; if (currentFocusedIndex >= tagsList.length) currentFocusedIndex = 0; } if (currentFocusedIndex === -1 && tagsList.length > 0) { currentFocusedIndex = 0; } let nextIndex = -1; let preventDefault = true; switch (e.key) { case 'ArrowRight': case 'ArrowDown': nextIndex = (currentFocusedIndex + 1) % tagsList.length; break; case 'ArrowLeft': case 'ArrowUp': nextIndex = (currentFocusedIndex - 1 + tagsList.length) % tagsList.length; break; case 'Home': nextIndex = 0; break; case 'End': nextIndex = tagsList.length - 1; break; case ' ': if (currentFocusedIndex !== -1) { const targetSpan = tagsList[currentFocusedIndex]; const mockEvent = { ctrlKey: isCtrl, metaKey: isCtrl, shiftKey: isShift, stopPropagation: () => {}, preventDefault: () => {} }; handleTagSelection(targetSpan, mockEvent); targetSpan.focus(); } break; case 'Enter': if (currentFocusedIndex !== -1) { const targetSpan = tagsList[currentFocusedIndex]; const mockEvent = { ctrlKey: false, metaKey: false, shiftKey: false, detail: 1, stopPropagation: () => {}, preventDefault: () => {} }; handleTagSelection(targetSpan, mockEvent); targetSpan.focus(); } break; case 'a': case 'A': if (isCtrl) { const selectAllMenuItem = document.getElementById('menu-select-all'); if (selectAllMenuItem && selectAllMenuItem.getAttribute('aria-disabled') !== 'true') { menuActionMap.selectAllTags(); } } else { preventDefault = false; } break; case 'Delete': case 'Backspace': const removeMenuItem = document.getElementById('menu-remove'); if (removeMenuItem && removeMenuItem.getAttribute('aria-disabled') !== 'true') { removeSelectedTags(); } break; default: preventDefault = false; return; } if (preventDefault) e.preventDefault(); if (nextIndex !== -1 && (e.key.startsWith('Arrow') || e.key === 'Home' || e.key === 'End')) { const targetSpan = tagsList[nextIndex]; if (isShift) { let anchorIndex = lastSelectedAnchorIndex; if (anchorIndex === -1) { anchorIndex = currentFocusedIndex >= 0 ? currentFocusedIndex : 0; } const startIndex = Math.min(anchorIndex, nextIndex); const endIndex = Math.max(anchorIndex, nextIndex); tagsList.forEach((span, index) => { const shouldBeSelected = (index >= startIndex && index <= endIndex); span.classList.toggle('selected', shouldBeSelected); span.setAttribute('aria-selected', String(shouldBeSelected)); }); } else if (!isCtrl) { tagsList.forEach((span, index) => { const shouldBeSelected = (index === nextIndex); span.classList.toggle('selected', shouldBeSelected); span.setAttribute('aria-selected', String(shouldBeSelected)); }); lastSelectedAnchorIndex = nextIndex; } const finalSelectedCount = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]').length; if (finalSelectedCount === 1 && !isShift) { showTagActions(targetSpan.dataset.tagValue); } else { hideTagActions(false); } updateMultiSelectActionButtons(); updateTagCountDisplay(); tagsList.forEach(tag => tag.tabIndex = -1); targetSpan.tabIndex = 0; targetSpan.focus(); } });
           tagDisplayArea.addEventListener('focusin', (e) => { if (e.target === tagDisplayArea) { setInitialTagFocus(); const firstFocusable = tagDisplayArea.querySelector('[tabindex="0"]'); if (firstFocusable && document.activeElement === tagDisplayArea) { firstFocusable.focus(); } } });
           tagDisplayArea.addEventListener('click', (e) => { if (e.target === tagDisplayArea && tagBeingEditedValue === null) { if (!e.ctrlKey && !e.metaKey && !e.shiftKey) { hideTagActions(true); setInitialTagFocus(); } } });

        // --- Tag/Search Suggestions Logic ---
           function showSuggestions(inputValue, source) { const suggestionsList = (source === 'tag') ? tagSuggestions : searchSuggestions; const inputEl = (source === 'tag') ? tagInput : searchInput; if (!suggestionsList || !inputValue || !inputEl) { hideSuggestions(); return; } const lowerInputValue = inputValue.toLowerCase(); const matchedTags = tags.filter(tag => tag.value.toLowerCase().includes(lowerInputValue)).sort((a, b) => { const aStarts = a.value.toLowerCase().startsWith(lowerInputValue); const bStarts = b.value.toLowerCase().startsWith(lowerInputValue); if (aStarts !== bStarts) { return aStarts ? -1 : 1; } return a.value.toLowerCase().localeCompare(b.value.toLowerCase()); }).slice(0, 10); suggestionsList.innerHTML = ''; activeSuggestionIndex = -1; currentSuggestionSource = source; if (matchedTags.length > 0) { matchedTags.forEach((tag, index) => { const li = document.createElement('li'); li.setAttribute('role', 'option'); li.id = `${source}-suggestion-${index}`; li.dataset.value = tag.value; const tagLower = tag.value.toLowerCase(); const indexMatch = tagLower.indexOf(lowerInputValue); if (indexMatch !== -1) { const before = tag.value.substring(0, indexMatch); const match = tag.value.substring(indexMatch, indexMatch + inputValue.length); const after = tag.value.substring(indexMatch + inputValue.length); li.innerHTML = `${before}<strong>${match}</strong>${after}`; } else { li.textContent = tag.value; } li.addEventListener('mousedown', handleSuggestionClick); suggestionsList.appendChild(li); }); suggestionsList.style.display = 'block'; inputEl.setAttribute('aria-expanded', 'true'); } else { hideSuggestions(); } }
           function hideSuggestions() { if(tagSuggestions) tagSuggestions.style.display = 'none'; if(searchSuggestions) searchSuggestions.style.display = 'none'; activeSuggestionIndex = -1; currentSuggestionSource = null; if(tagInput) { tagInput.removeAttribute('aria-activedescendant'); tagInput.setAttribute('aria-expanded', 'false'); } if(searchInput) { searchInput.removeAttribute('aria-activedescendant'); searchInput.setAttribute('aria-expanded', 'false'); } }
           function handleSuggestionClick(event) { event.preventDefault(); const selectedValue = event.target.closest('li')?.dataset.value; if (!selectedValue || !currentSuggestionSource) return; const inputEl = (currentSuggestionSource === 'tag') ? tagInput : searchInput; if (!inputEl) return; if (currentSuggestionSource === 'tag') { const currentValue = inputEl.value; const lastCommaIndex = currentValue.lastIndexOf(','); const beforeLastComma = (lastCommaIndex === -1) ? '' : currentValue.substring(0, lastCommaIndex + 1); inputEl.value = `${beforeLastComma.trimStart()} ${selectedValue}, `; } else { inputEl.value = selectedValue; inputEl.dispatchEvent(new Event('input', { bubbles:true })); } hideSuggestions(); inputEl.focus(); if (currentSuggestionSource === 'tag') { inputEl.selectionStart = inputEl.selectionEnd = inputEl.value.length; } }
           function updateSuggestionHighlight(source, direction) { const suggestionsList = (source === 'tag') ? tagSuggestions : searchSuggestions; const inputEl = (source === 'tag') ? tagInput : searchInput; if (!suggestionsList || !inputEl) return; const items = suggestionsList.querySelectorAll('li[data-value]'); if (!items || items.length === 0) return; const currentActive = suggestionsList.querySelector('li.active'); if(currentActive) currentActive.classList.remove('active'); inputEl.removeAttribute('aria-activedescendant'); activeSuggestionIndex += direction; if (activeSuggestionIndex < 0) { activeSuggestionIndex = items.length - 1; } else if (activeSuggestionIndex >= items.length) { activeSuggestionIndex = 0; } const newActive = items[activeSuggestionIndex]; if (newActive) { newActive.classList.add('active'); inputEl.setAttribute('aria-activedescendant', newActive.id); newActive.scrollIntoView({ block: 'nearest' }); } }

        // --- Core Logic: Tag Management ---
           function addTag() { hideSuggestions(); if (tagBeingEditedValue !== null) return; const tagInputValues = tagInput.value.split(',').map(t => t.trim().replace(/\s+/g, ' ')).filter(Boolean); const entryRefs = entryInput.value.split(',').map(e => e.trim().replace(/\s+/g, ' ')).filter(Boolean); const uniqueEntriesToAdd = [...new Set(entryRefs)]; if (tagInputValues.length === 0) { showMessage("Tag name(s) cannot be empty.", 'error'); tagInput.focus(); return; } saveStateForUndo(`Add Tag(s): ${tagInputValues.join(', ')}`); let changesMade = false; let addedTags = []; let updatedTags = []; tagInputValues.forEach(newTagValue => { const existingTag = findTagObject(newTagValue); if (existingTag) { let entriesAddedToExisting = 0; if (uniqueEntriesToAdd.length > 0) { if (!Array.isArray(existingTag.entries)) existingTag.entries = []; const currentEntriesLower = new Set(existingTag.entries.map(e => String(e).toLowerCase())); uniqueEntriesToAdd.forEach(entry => { if (!currentEntriesLower.has(String(entry).toLowerCase())) { existingTag.entries.push(entry); entriesAddedToExisting++; } }); if (entriesAddedToExisting > 0) { existingTag.count = existingTag.entries.length; updatedTags.push({ name: existingTag.value, count: entriesAddedToExisting }); changesMade = true; } } } else { tags.push({ value: newTagValue, count: uniqueEntriesToAdd.length, entries: [...uniqueEntriesToAdd] }); addedTags.push(newTagValue); changesMade = true; } }); let msgParts = []; if (addedTags.length > 0) msgParts.push(`${addedTags.length} new tag(s) added`); if (updatedTags.length > 0) { const totalEntries = updatedTags.reduce((sum, t) => sum + t.count, 0); msgParts.push(`${totalEntries} entr${totalEntries !== 1 ? 'ies' : 'y'} added to ${updatedTags.length} existing tag(s)`); } if (tagInputValues.length > 0 && !changesMade) { msgParts.push("Tag(s) already exist" + (uniqueEntriesToAdd.length > 0 ? " with these entries (no changes made)" : " (no changes made)")); } const messageText = msgParts.length > 0 ? msgParts.join('. ') + '.' : 'No changes needed.'; const messageType = changesMade ? 'success' : 'info'; if (changesMade) { tags.sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase())); setUnsavedChanges(true); currentSearchTerm = ''; currentEntryFilter = ''; activeEntryFilter = ''; if(searchInput) searchInput.value = ''; if(entryFilterInput) entryFilterInput.value = ''; if(clearSearchBtn) clearSearchBtn.style.display = 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none'; lastSelectedAnchorIndex = -1; renderTags(); renderCurrentEntries(); hideTagActions(true); resetInputAreaAppearance(); setInitialTagFocus(); } else { tagInput.select(); } showMessage(messageText, messageType); updateMultiSelectActionButtons(); tagInput.focus(); }
           function removeSingleTag(tagValueToRemove) { hideSuggestions(); if (tagBeingEditedValue !== null) return; const tagIndex = tags.findIndex(t => t.value.toLowerCase() === tagValueToRemove.toLowerCase()); if (tagIndex === -1) { showMessage(`Tag "${tagValueToRemove}" not found.`, 'error'); return; } const tagObject = tags[tagIndex]; if (confirm(`Remove tag "${tagObject.value}" (${tagObject.count} entries)?\n\nThis can be undone.`)) { saveStateForUndo(`Remove Tag "${tagObject.value}"`); tags.splice(tagIndex, 1); setUnsavedChanges(true); hideTagActions(true); currentSearchTerm = ''; currentEntryFilter = ''; activeEntryFilter = ''; if(searchInput) searchInput.value = ''; if(entryFilterInput) entryFilterInput.value = ''; if(clearSearchBtn) clearSearchBtn.style.display = 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none'; lastSelectedAnchorIndex = -1; renderTags(); renderCurrentEntries(); setInitialTagFocus(); showMessage(`Tag "${tagObject.value}" removed.`, 'success'); } }
           function removeSelectedTags() { hideSuggestions(); if (!tagDisplayArea || tagBeingEditedValue !== null) return; const selectedSpans = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]'); if (selectedSpans.length === 0) { showMessage("No tags selected to remove.", "info"); return; } const tagValuesToRemove = Array.from(selectedSpans).map(span => span.dataset.tagValue); if (confirm(`Remove ${selectedSpans.length} selected tag(s)?\n(${tagValuesToRemove.slice(0, 5).join(', ')}${tagValuesToRemove.length > 5 ? ', ...' : ''})\n\nThis can be undone.`)) { saveStateForUndo(`Remove ${selectedSpans.length} Selected Tags`); const valuesToRemoveLower = new Set(tagValuesToRemove.map(v => v.toLowerCase())); const originalCount = tags.length; tags = tags.filter(tag => !valuesToRemoveLower.has(tag.value.toLowerCase())); const removedCount = originalCount - tags.length; setUnsavedChanges(true); hideTagActions(true); currentSearchTerm = ''; currentEntryFilter = ''; activeEntryFilter = ''; if(searchInput) searchInput.value = ''; if(entryFilterInput) entryFilterInput.value = ''; if(clearSearchBtn) clearSearchBtn.style.display = 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none'; lastSelectedAnchorIndex = -1; renderTags(); renderCurrentEntries(); setInitialTagFocus(); showMessage(`${removedCount} tag(s) removed.`, 'success'); } else { showMessage("Remove selected tags cancelled.", "info"); } }
        function disableAllButtonsExceptEdit() { const buttonsToDisable = document.querySelectorAll('.action-button-row button:not(#updateTagBtn):not(#cancelUpdateBtn), #sortTagsBtn, #combineSelectedTagsBtn',); buttonsToDisable.forEach(btn => btn.disabled = true); if (copySelectedTagsBtn) copySelectedTagsBtn.disabled = true; if (removeSelectedTagsBtn) removeSelectedTagsBtn.disabled = true; if (addFirstTagBtn) addFirstTagBtn.disabled = true; // if (openFilePlaceholderBtn) openFilePlaceholderBtn.disabled = true; // Handled by menu state now
        updateMenuItemStates(); }
        function enableAllButtons() { const allButtons = document.querySelectorAll('button'); allButtons.forEach(btn => btn.disabled = false); updateUndoRedoButtons(); updateMultiSelectActionButtons(); updateFileNameDisplay(); if(sortTagsBtn) sortTagsBtn.disabled = tags.length <= 1; if (combineSelectedTagsBtn) {
                const selectedCount = tagDisplayArea?.querySelectorAll('span.tag-item[aria-selected="true"]').length ?? 0;
                combineSelectedTagsBtn.disabled = (selectedCount < 2);
            }
             if (addFirstTagBtn) addFirstTagBtn.disabled = false; if(tagDisplayContainer) tagDisplayContainer.classList.remove('editing-active'); if (searchInput) { searchInput.disabled = false; if(clearSearchBtn) clearSearchBtn.style.display = searchInput.value ? 'inline-block' : 'none'; } if (entryFilterInput) { entryFilterInput.disabled = false; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = (entryFilterInput.value || activeEntryFilter) ? 'inline-block' : 'none'; } setInitialTagFocus(); updateMenuItemStates(); } // Ensure placeholder state is also correct
             function startEditTag(tagValueToEdit) { hideSuggestions(); if (tagBeingEditedValue !== null) return; const tagObject = findTagObject(tagValueToEdit); if (!tagObject) return; getVisibleTagSpans().forEach(span => { const isTarget = span.dataset.tagValue === tagValueToEdit; span.classList.toggle('selected', isTarget); span.setAttribute('aria-selected', String(isTarget)); }); lastSelectedAnchorIndex = getVisibleTagSpans().findIndex(s => s.dataset.tagValue === tagValueToEdit); if (tagDisplayContainer) tagDisplayContainer.classList.add('editing-active'); hideTagActions(false); tagInput.value = tagObject.value; tagInput.placeholder = "Enter updated tag name"; entryInput.value = ''; entryInput.disabled = true; if (searchInput) searchInput.disabled = true; if(clearSearchBtn) clearSearchBtn.style.display = 'none'; if (entryFilterInput) entryFilterInput.disabled = true; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none'; tagBeingEditedValue = tagObject.value; addTagBtn.style.display = 'none'; updateTagBtn.style.display = 'inline-flex'; cancelUpdateBtn.style.display = 'inline-flex'; disableAllButtonsExceptEdit(); showMessage(`Editing tag name "${tagObject.value}". Enter=Save, Esc=Cancel.`, 'info', 6000); setTimeout(() => { if(tagInput) { tagInput.focus(); tagInput.select(); } }, 50); }
             function updateTag() { hideSuggestions(); if (tagBeingEditedValue === null) return; const updatedValue = tagInput.value.trim().replace(/\s+/g, ' '); const originalValue = tagBeingEditedValue; if (!updatedValue) { showMessage("Tag name cannot be empty.", 'error'); tagInput.focus(); return; } const lowerUpdated = updatedValue.toLowerCase(); const lowerOriginal = originalValue.toLowerCase(); if (lowerUpdated !== lowerOriginal && tags.some(t => t.value.toLowerCase() === lowerUpdated)) { showMessage(`Tag "${updatedValue}" already exists. Cannot rename.`, 'error'); tagInput.select(); return; } const tagIndex = tags.findIndex(t => t.value.toLowerCase() === lowerOriginal); if (tagIndex !== -1) { saveStateForUndo(`Update Tag "${originalValue}" to "${updatedValue}"`); tags[tagIndex].value = updatedValue; const finalUpdatedValue = tags[tagIndex].value; tags.sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase())); setUnsavedChanges(true); tagBeingEditedValue = null; resetInputAreaAppearance(); enableAllButtons(); currentSearchTerm = ''; currentEntryFilter = ''; activeEntryFilter = ''; if(searchInput) searchInput.value = ''; if(entryFilterInput) entryFilterInput.value = ''; if(clearSearchBtn) clearSearchBtn.style.display = 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none'; lastSelectedAnchorIndex = -1; renderTags(); renderCurrentEntries(); const newTagSpan = getVisibleTagSpan(finalUpdatedValue); if (newTagSpan) { getVisibleTagSpans().forEach(s => { const isTarget = s === newTagSpan; s.classList.toggle('selected', isTarget); s.setAttribute('aria-selected', String(isTarget)); }); lastSelectedAnchorIndex = getVisibleTagSpans().indexOf(newTagSpan); setInitialTagFocus(finalUpdatedValue); newTagSpan.focus(); showTagActions(finalUpdatedValue); } else { hideTagActions(true); setInitialTagFocus(); } showMessage(`Tag "${originalValue}" updated to "${finalUpdatedValue}".`, 'success'); } else { showMessage(`Error: Original tag "${originalValue}" not found during update.`, 'error'); cancelEdit(true); } }
             function cancelEdit(preventActionRedisplay = false) { hideSuggestions(); const wasEditing = tagBeingEditedValue; if (!wasEditing) return; tagBeingEditedValue = null; resetInputAreaAppearance(); enableAllButtons(); if (messageArea?.classList.contains('info') && messageArea.textContent.startsWith("Editing tag name")) { messageArea.classList.remove('visible'); } const spanToReselect = wasEditing ? getVisibleTagSpan(wasEditing) : null; if (spanToReselect && !preventActionRedisplay) { getVisibleTagSpans().forEach(s => { const isTarget = s === spanToReselect; s.classList.toggle('selected', isTarget); s.setAttribute('aria-selected', String(isTarget)); }); lastSelectedAnchorIndex = getVisibleTagSpans().indexOf(spanToReselect); setInitialTagFocus(wasEditing); spanToReselect.focus(); showTagActions(wasEditing); } else { hideTagActions(true); setInitialTagFocus(); if (preventActionRedisplay) renderTags(); } tagInput.focus(); }
             function sortTags() { hideSuggestions(); if (tagBeingEditedValue !== null) cancelEdit(true); if (tags.length <= 1) { showMessage('Not enough tags to sort.', 'info'); return; } const selectedValues = new Set(Array.from(tagDisplayArea?.querySelectorAll('span.tag-item[aria-selected="true"]') ?? []).map(span => span.dataset.tagValue)); const focusedElement = document.activeElement?.closest('.tag-item'); const focusedValue = focusedElement ? focusedElement.dataset.tagValue : null; hideTagActions(false); saveStateForUndo("Sort Tags"); tags.sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase())); setUnsavedChanges(true); currentSearchTerm = ''; currentEntryFilter = ''; activeEntryFilter = ''; if(searchInput) searchInput.value = ''; if(entryFilterInput) entryFilterInput.value = ''; if(clearSearchBtn) clearSearchBtn.style.display = 'none'; if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none'; lastSelectedAnchorIndex = -1; renderTags(); renderCurrentEntries(); getVisibleTagSpans().forEach(span => { const shouldBeSelected = selectedValues.has(span.dataset.tagValue); span.classList.toggle('selected', shouldBeSelected); span.setAttribute('aria-selected', String(shouldBeSelected)); }); const newFocusSpan = focusedValue ? getVisibleTagSpan(focusedValue) : null; if (newFocusSpan) { lastSelectedAnchorIndex = getVisibleTagSpans().indexOf(newFocusSpan); setInitialTagFocus(focusedValue); newFocusSpan.focus(); } else { const firstSelected = tagDisplayArea.querySelector('span.tag-item[aria-selected="true"]'); if(firstSelected) { lastSelectedAnchorIndex = getVisibleTagSpans().indexOf(firstSelected); setInitialTagFocus(firstSelected.dataset.tagValue); firstSelected.focus(); } else { setInitialTagFocus(); } } const reSelectedCount = tagDisplayArea?.querySelectorAll('span.tag-item[aria-selected="true"]').length ?? 0; if (reSelectedCount === 1) { showTagActions(tagDisplayArea.querySelector('span.tag-item[aria-selected="true"]').dataset.tagValue); } else { hideTagActions(false); } updateMultiSelectActionButtons(); showMessage('Tags sorted alphabetically (A-Z).', 'success'); }

function combineTags() {
            hideSuggestions();
            if (tagBeingEditedValue !== null) {
                showMessage("Finish editing before combining tags.", "info");
                return;
            }
            if (!tagDisplayArea) return;

            const selectedSpans = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]');
            const selectedCount = selectedSpans.length;

            if (selectedCount < 2) {
                showMessage("Select 2 or more tags to combine.", "info");
                return;
            }

            const selectedTagValues = Array.from(selectedSpans).map(span => span.dataset.tagValue);

            // Prompt user to choose which name to keep
            let promptMessage = `Combine ${selectedCount} tags into one.\n\nSelect the number of the tag name to KEEP:\n`;
            selectedTagValues.forEach((value, index) => {
                promptMessage += `\n${index + 1}. ${value}`;
            });
            promptMessage += '\n\nEnter number:';

            const choiceInput = prompt(promptMessage);

            if (choiceInput === null) {
                showMessage("Combine operation cancelled.", "info");
                return;
            }

            const choiceIndex = parseInt(choiceInput, 10) - 1;

            if (isNaN(choiceIndex) || choiceIndex < 0 || choiceIndex >= selectedTagValues.length) {
                showMessage("Invalid selection. Please enter a valid number.", "error");
                return;
            }

            const targetTagName = selectedTagValues[choiceIndex];
            const tagsToRemove = selectedTagValues.filter(value => value !== targetTagName);
            const tagsToRemoveLower = new Set(tagsToRemove.map(v => v.toLowerCase()));

            // Gather all unique entries from the selected tags
            const combinedEntries = new Set();
            tags.forEach(tag => {
                if (selectedTagValues.includes(tag.value) && Array.isArray(tag.entries)) {
                    tag.entries.forEach(entry => combinedEntries.add(String(entry).trim().replace(/\s+/g, ' ')));
                }
            });
            const finalEntriesArray = Array.from(combinedEntries);

            // --- Perform the combination ---
            saveStateForUndo(`Combine ${selectedCount} Tags into "${targetTagName}"`);

            // Find the target tag and update its entries
            const targetTagIndex = tags.findIndex(tag => tag.value === targetTagName);
            if (targetTagIndex !== -1) {
                tags[targetTagIndex].entries = finalEntriesArray;
                tags[targetTagIndex].count = finalEntriesArray.length;
            } else {
                // This case *shouldn't* happen if the tag was selected, but as a fallback:
                console.error(`Combine Tags: Target tag "${targetTagName}" not found in state array.`);
                showMessage(`Error: Could not find the target tag "${targetTagName}" to combine into.`, "error");
                // Attempt to recover undo state if possible
                history.pop(); // Remove the problematic undo state
                updateUndoRedoButtons();
                return; // Stop the operation
            }

            // Filter out the other combined tags
            const originalTagCount = tags.length;
            tags = tags.filter(tag => !tagsToRemoveLower.has(tag.value.toLowerCase()));
            const removedCount = originalTagCount - tags.length;

            // Sort again
            tags.sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase()));

            setUnsavedChanges(true);
            hideTagActions(true); // Clear selection and actions panel

            // Reset filters (optional, but often desired after a merge)
            currentSearchTerm = '';
            currentEntryFilter = '';
            activeEntryFilter = '';
            if(searchInput) searchInput.value = '';
            if(entryFilterInput) entryFilterInput.value = '';
            if(clearSearchBtn) clearSearchBtn.style.display = 'none';
            if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = 'none';
            lastSelectedAnchorIndex = -1;

            renderTags();
            renderCurrentEntries();
            setInitialTagFocus(); // Reset focus, don't try to focus the merged tag specifically for now

            showMessage(`${selectedCount} tags combined into "${targetTagName}". ${removedCount} tag(s) removed.`, 'success');
            updateMultiSelectActionButtons(); // Update button states (Combine should be disabled now)
            updateTagCountDisplay();

        } // End combineTags
        //

        
        // --- Core Logic: Entry Management ---
             function addDiaryEntry(tagValue, entryInputString) { if (tagBeingEditedValue !== null) return; const tagObject = findTagObject(tagValue); if (!tagObject) { showMessage(`Tag "${tagValue}" not found.`, "error"); return; } const actionInput = tagActionsArea?.querySelector('#actionEntryInput'); const potentialEntries = entryInputString.split(',').map(e => e.trim().replace(/\s+/g, ' ')).filter(Boolean); if (potentialEntries.length === 0) { showMessage("No valid entry references provided.", 'info'); actionInput?.focus(); return; } saveStateForUndo(`Add Entries to "${tagValue}"`); let addedCount = 0, duplicateCount = 0; if (!Array.isArray(tagObject.entries)) tagObject.entries = []; const currentEntriesLower = new Set(tagObject.entries.map(e => String(e).toLowerCase())); potentialEntries.forEach(newEntry => { if (currentEntriesLower.has(String(newEntry).toLowerCase())) { duplicateCount++; } else { tagObject.entries.push(newEntry); currentEntriesLower.add(String(newEntry).toLowerCase()); addedCount++; } }); if (addedCount > 0) { tagObject.count = tagObject.entries.length; setUnsavedChanges(true); const focusedVal = document.activeElement?.closest('.tag-item')?.dataset.tagValue ?? tagValue; renderTags(); renderCurrentEntries(); showTagActions(tagValue); const refreshedActionInput = tagActionsArea?.querySelector('#actionEntryInput'); if (refreshedActionInput) { refreshedActionInput.value = ''; refreshedActionInput.focus(); } else { const tagSpan = getVisibleTagSpan(focusedVal); if(tagSpan) tagSpan.focus(); } let msg = `${addedCount} entr${addedCount > 1 ? 'ies' : 'y'} added to "${tagValue}".`; if (duplicateCount > 0) msg += ` (${duplicateCount} duplicate${duplicateCount > 1 ? 's' : ''} ignored.)`; showMessage(msg, 'success', 3000); } else if (duplicateCount > 0) { showMessage(`All provided entries already exist for "${tagValue}".`, 'info'); actionInput?.select(); } }
             function removeDiaryEntry(tagValue, entryIndexToRemove) { if (tagBeingEditedValue !== null) return; const tagObject = findTagObject(tagValue); if (!tagObject || !Array.isArray(tagObject.entries) || entryIndexToRemove < 0 || entryIndexToRemove >= tagObject.entries.length) { showMessage("Could not remove entry: Invalid tag or index.", "error"); return; } const removedEntry = tagObject.entries[entryIndexToRemove]; if (confirm(`Remove entry "${removedEntry}" association from tag "${tagValue}"?\n\nThis action can be undone.`)) { saveStateForUndo(`Remove Entry "${removedEntry}" from "${tagValue}"`); tagObject.entries.splice(entryIndexToRemove, 1); tagObject.count = tagObject.entries.length; setUnsavedChanges(true); const focusedVal = document.activeElement?.closest('.tag-item')?.dataset.tagValue ?? tagValue; renderTags(); renderCurrentEntries(); showTagActions(tagValue); showMessage(`Entry "${removedEntry}" removed from "${tagValue}".`, 'success', 2000); const actionInput = tagActionsArea?.querySelector('#actionEntryInput'); const tagSpan = getVisibleTagSpan(focusedVal); if(actionInput) actionInput.focus(); else if(tagSpan) tagSpan.focus(); } else { showMessage(`Removal of entry "${removedEntry}" cancelled.`, "info", 1500); } }

        // --- Helper: Process Imported JSON Data ---
             function processImportedJsonData(jsonData, sourceName, showAlerts = true) { let feedback = { success: false, message: '', type: 'error', loadedTags: [], duplicates: 0, invalid: 0 }; if (!Array.isArray(jsonData)) { feedback.message = `Error loading from "${sourceName}": Data is not a valid JSON array.`; if(showAlerts) showMessage(feedback.message, feedback.type); return feedback; } const sanitizedTags = []; const importedValuesLower = new Set(); for (const item of jsonData) { if (typeof item !== 'object' || item === null) { feedback.invalid++; continue; } const value = String(item.value ?? '').trim().replace(/\s+/g, ' '); if (!value) { feedback.invalid++; continue; } const lowerValue = value.toLowerCase(); if (importedValuesLower.has(lowerValue)) { console.warn(`Duplicate tag name "${value}" found within "${sourceName}" and was skipped.`); feedback.duplicates++; continue; } importedValuesLower.add(lowerValue); const entries = Array.isArray(item.entries) ? [...new Set(item.entries.map(String).map(s => s.trim().replace(/\s+/g, ' ')).filter(Boolean))] : []; sanitizedTags.push({ value, count: entries.length, entries }); } feedback.loadedTags = sanitizedTags; feedback.success = true; feedback.type = 'success'; feedback.message = `Loaded ${feedback.loadedTags.length} tags from "${sourceName}".`; if (feedback.duplicates > 0) feedback.message += ` (${feedback.duplicates} duplicate name${feedback.duplicates > 1 ? 's were' : ' was'} ignored.)`; if (feedback.invalid > 0) feedback.message += ` (${feedback.invalid} invalid item${feedback.invalid > 1 ? 's were' : ' was'} ignored.)`; if (showAlerts && (feedback.loadedTags.length > 0 || feedback.duplicates > 0 || feedback.invalid > 0)) { const messageType = feedback.loadedTags.length > 0 ? feedback.type : 'info'; const duration = (feedback.duplicates > 0 || feedback.invalid > 0) ? 5000 : 3500; showMessage(feedback.message, messageType, duration); } else if (showAlerts && feedback.loadedTags.length === 0 && feedback.duplicates === 0 && feedback.invalid === 0) { showMessage(`File "${sourceName}" contained no valid tags.`, 'info'); } return feedback; }

        // --- Core Logic: Data I/O and Copy ---
             function copySelectedTags() { hideSuggestions(); if (!tagDisplayArea || tagBeingEditedValue !== null) return; const selectedSpans = tagDisplayArea.querySelectorAll('span.tag-item[aria-selected="true"]'); if (selectedSpans.length === 0) { showMessage("No tags selected to copy.", "info"); return; } const tagValues = Array.from(selectedSpans).map(span => span.dataset.tagValue); navigator.clipboard.writeText(tagValues.join(', ')).then(() => { showMessage(`Copied ${tagValues.length} tag(s): "${tagValues.join(', ')}"`, 'success', 4000); }).catch(err => { console.error('Failed to copy tags: ', err); showMessage('Failed to copy tags to clipboard.', 'error'); }); }
             async function openFile() { hideSuggestions(); if (!supportsFileSystemAccess) { showMessage("File System Access API not supported by your browser.", "error"); return; } if (tagBeingEditedValue !== null) cancelEdit(true); if (!(await confirmDiscardUnsaved())) { showMessage("Open operation cancelled.", "info"); return; } try { const [handle] = await window.showOpenFilePicker({ types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] }}], multiple: false }); const file = await handle.getFile(); const contents = await file.text(); let originalParsedData; try { originalParsedData = JSON.parse(contents); } catch (parseError) { throw new Error(`Invalid JSON format in "${handle.name}".`); } const { dataToLoad, backupLoaded, sourceName } = await checkForAndHandleBackup(handle.name, originalParsedData); resetStateBeforeLoad(); const result = processImportedJsonData(dataToLoad, sourceName, true); if (result.success) { tags = result.loadedTags; currentFileHandle = handle; currentFileName = handle.name; if (backupLoaded) { hasUnsavedChanges = true; } else { hasUnsavedChanges = false; } finalizeLoad(); } else { resetStateBeforeLoad(); finalizeLoad(); } } catch (error) { if (error.name !== 'AbortError') { console.error("Error opening file:", error); showMessage(`Error opening file: ${error.message}`, 'error'); resetStateBeforeLoad(); finalizeLoad(); } else { showMessage('File open cancelled.', 'info'); } } }
             async function saveFile() { hideSuggestions(); if (tagBeingEditedValue !== null) { showMessage("Finish editing before saving.", "info"); return; } if (!hasUnsavedChanges) { showMessage("No unsaved changes to save.", "info"); return; } if (!supportsFileSystemAccess) { if (currentFileName !== "Untitled") { saveTagsToLocalStorage(); showMessage(`Changes backed up to browser storage for "${currentFileName}". Use "Save As..." if File API becomes available.`, "info", 4000); } else { showMessage("Cannot save Untitled file without browser File System Access support.", "error"); } updateFileNameDisplay(); return; } if (!currentFileHandle) { console.log("No file handle, triggering Save As..."); await saveFileAs(); return; } try { if (await currentFileHandle.queryPermission({ mode: 'readwrite' }) !== 'granted') { if (await currentFileHandle.requestPermission({ mode: 'readwrite' }) !== 'granted') { throw new Error('Permission to save file denied.'); } } const writableStream = await currentFileHandle.createWritable(); const dataToExport = tags.map(tag => ({ value: tag.value, entries: tag.entries ?? [] })); await writableStream.write(JSON.stringify(dataToExport, null, 2)); await writableStream.close(); setUnsavedChanges(false); removeBackup(currentFileName); showMessage(`Changes saved to "${currentFileName}".`, 'success'); } catch (error) { console.error("Error saving file:", error); let userMessage = `Error saving file: ${error.message}`; if (error.name === 'NotFoundError') { userMessage = `Error: File "${currentFileName}" not found/moved. Use 'Save As...' to save to a new location.`; currentFileHandle = null; setUnsavedChanges(true); } else if (error.message.includes('user gesture')) { userMessage = `Error saving: Browser requires a user interaction (like a click). Try saving again.`; } showMessage(userMessage, 'error'); updateFileNameDisplay(); } }
             async function saveFileAs() {
                hideSuggestions();
                if (!supportsFileSystemAccess) {
                    showMessage("File System Access API not supported by your browser.", "error");
                    return;
                }
                if (tagBeingEditedValue !== null) {
                    showMessage("Finish editing before saving.", "info");
                    return;
                }
                try {
                    const suggestedName = currentFileName !== "Untitled" ? currentFileName : 'keyword-tags.json';
        // Show the save file picker
                    const handle = await window.showSaveFilePicker({
                        suggestedName: suggestedName,
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    const writableStream = await handle.createWritable();
                    const dataToExport = tags.map(tag => ({ value: tag.value, entries: tag.entries ?? [] }));
                    await writableStream.write(JSON.stringify(dataToExport, null, 2));
                    await writableStream.close();
                    removeBackup(handle.name);
                    removeBackup(currentFileName);
                    currentFileHandle = handle;
                    currentFileName = handle.name;
                    setUnsavedChanges(false);
                    updateFileNameDisplay();
                    showMessage(`Tags saved as "${currentFileName}".`, 'success');

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error("Error saving file as:", error);
                        showMessage(`Error saving file: ${error.message}`, 'error');
                    } else {
                        showMessage('Save As cancelled.', 'info');
                    }
                    updateFileNameDisplay();
                }
            }


        // --- Event Listeners Setup ---
            addTagBtn?.addEventListener('click', addTag);
            updateTagBtn?.addEventListener('click', updateTag);
            cancelUpdateBtn?.addEventListener('click', () => cancelEdit());
            sortTagsBtn?.addEventListener('click', sortTags);
            copySelectedTagsBtn?.addEventListener('click', copySelectedTags);
            removeSelectedTagsBtn?.addEventListener('click', removeSelectedTags);
            combineSelectedTagsBtn?.addEventListener('click', combineTags);

        // --- Input Listeners for Suggestions ---
            tagInput?.addEventListener('input', () => { const value = tagInput.value; const lastCommaIndex = value.lastIndexOf(','); const currentPart = (lastCommaIndex === -1) ? value.trimStart() : value.substring(lastCommaIndex + 1).trimStart(); if (currentPart) { showSuggestions(currentPart, 'tag'); } else { hideSuggestions(); } });
            tagInput?.addEventListener('blur', () => { setTimeout(hideSuggestions, 150); });
        tagInput?.addEventListener('keydown', (event) => { const suggestionsList = tagSuggestions; const suggestionsVisible = suggestionsList && suggestionsList.style.display === 'block'; if (suggestionsVisible) { switch (event.key) { case 'ArrowDown': event.preventDefault(); updateSuggestionHighlight('tag', 1); break; case 'ArrowUp': event.preventDefault(); updateSuggestionHighlight('tag', -1); break; case 'Enter': event.preventDefault(); if (activeSuggestionIndex !== -1) { const activeItem = suggestionsList.querySelector('li.active'); if (activeItem) { activeItem.dispatchEvent(new MouseEvent('mousedown', { bubbles: true })); } } else { hideSuggestions(); if (tagBeingEditedValue !== null) { updateTagBtn.click(); } else { addTagBtn.click(); } } break; case 'Escape': /* Handled globally */ break; case 'Tab': if (activeSuggestionIndex !== -1) { const activeItem = suggestionsList.querySelector('li.active'); if (activeItem) { activeItem.dispatchEvent(new MouseEvent('mousedown', { bubbles: true })); event.preventDefault(); } else { hideSuggestions(); } } else { hideSuggestions(); } break; } } else if (event.key === 'Enter') { event.preventDefault(); if (tagBeingEditedValue !== null) { updateTagBtn.click(); } else { addTagBtn.click(); } } });
            searchInput?.addEventListener('input', () => { const value = searchInput.value.trim(); if (value) { showSuggestions(value, 'search'); } else { hideSuggestions(); } currentSearchTerm = value; renderTags(); if(clearSearchBtn) clearSearchBtn.style.display = currentSearchTerm ? 'inline-block' : 'none'; });
            searchInput?.addEventListener('blur', () => { setTimeout(hideSuggestions, 150); });
        searchInput?.addEventListener('keydown', (event) => { const suggestionsList = searchSuggestions; const suggestionsVisible = suggestionsList && suggestionsList.style.display === 'block'; if (suggestionsVisible) { switch (event.key) { case 'ArrowDown': event.preventDefault(); updateSuggestionHighlight('search', 1); break; case 'ArrowUp': event.preventDefault(); updateSuggestionHighlight('search', -1); break; case 'Enter': event.preventDefault(); if (activeSuggestionIndex !== -1) { const activeItem = suggestionsList.querySelector('li.active'); if (activeItem) { activeItem.dispatchEvent(new MouseEvent('mousedown', { bubbles: true })); } } else { currentSearchTerm = searchInput.value.trim(); renderTags(); hideSuggestions(); } break; case 'Escape': /* Handled globally */ break; case 'Tab': if (activeSuggestionIndex !== -1) { const activeItem = suggestionsList.querySelector('li.active'); if (activeItem) { activeItem.dispatchEvent(new MouseEvent('mousedown', { bubbles: true })); event.preventDefault(); } else { hideSuggestions(); } } else { hideSuggestions(); } break; } } else if (event.key === 'Enter') { event.preventDefault(); currentSearchTerm = searchInput.value.trim(); renderTags(); } });
            entryInput?.addEventListener('keypress', (event) => { if (event.key === 'Enter' && tagBeingEditedValue === null) { event.preventDefault(); addTagBtn?.click(); } });

        // Filter Input Listeners
            searchInput?.addEventListener('input', () => { if (tagBeingEditedValue !== null) return; currentSearchTerm = searchInput.value.trim(); renderTags(); if(clearSearchBtn) clearSearchBtn.style.display = currentSearchTerm ? 'inline-block' : 'none'; });
            clearSearchBtn?.addEventListener('click', () => { if(searchInput && tagBeingEditedValue === null) { searchInput.value = ''; currentSearchTerm = ''; hideSuggestions(); renderTags(); clearSearchBtn.style.display = 'none'; searchInput.focus(); } });
            entryFilterInput?.addEventListener('input', () => { if (tagBeingEditedValue !== null) return; if (activeEntryFilter) { activeEntryFilter = ''; renderCurrentEntries(); } currentEntryFilter = entryFilterInput.value.trim(); renderTags(); if(clearEntryFilterBtn) clearEntryFilterBtn.style.display = currentEntryFilter ? 'inline-block' : 'none'; });
            clearEntryFilterBtn?.addEventListener('click', () => { if(entryFilterInput && tagBeingEditedValue === null) { entryFilterInput.value = ''; currentEntryFilter = ''; activeEntryFilter = ''; renderTags(); renderCurrentEntries(); clearEntryFilterBtn.style.display = 'none'; entryFilterInput.focus(); } });
            entryFilterInput?.addEventListener('keydown', (e) => { if (e.key === 'Enter') e.preventDefault(); });

                // Filter Input Listeners
             searchInput?.addEventListener('input', () => { /* ... */ });
             clearSearchBtn?.addEventListener('click', () => { /* ... */ });
             entryFilterInput?.addEventListener('input', () => { /* ... */ });
             clearEntryFilterBtn?.addEventListener('click', () => { /* ... */ });
             entryFilterInput?.addEventListener('keydown', (e) => { /* ... */ });

        // ---->> ADD THE NEW LISTENERS HERE <<----
            fitTagsBtn?.addEventListener('click', (e) => toggleFitToScreen(e.currentTarget));
            fitEntriesBtn?.addEventListener('click', (e) => toggleFitToScreen(e.currentTarget));
            window.addEventListener('resize', handleResizeFit);

        // Placeholder Button Listeners
             addFirstTagBtn?.addEventListener('click', () => { /* ... */ });
             openFilePlaceholderBtn?.addEventListener('click', () => { /* ... */ });

        // --- Event Listeners for Menu ---
             menuToggles.forEach(toggle => { /* ... */ });

        // Placeholder Button Listeners
            addFirstTagBtn?.addEventListener('click', () => { tagInput?.focus(); showMessage("Enter your first tag above.", "info", 2000); });
            openFilePlaceholderBtn?.addEventListener('click', () => {
                if (supportsFileSystemAccess && tagBeingEditedValue === null) {
                    openFile();
                } else if (!supportsFileSystemAccess) {
                    showMessage("Cannot open file: Browser lacks File System Access support.", "error");
                } else {
                    showMessage("Cannot open file while editing a tag.", "info");
                }
            });

        // --- Event Listeners for Menu ---
            menuToggles.forEach(toggle => {
             toggle.addEventListener('click', (e) => {
                 e.stopPropagation();
                 toggleMenuDropdown(toggle);
             });
             toggle.addEventListener('mouseup', (e) => e.target.blur());
             toggle.addEventListener('mouseenter', (e) => {
                 if (window.innerWidth <= 768) return;
                 const hoveredToggleButton = e.currentTarget;
                 const hoveredDropdownId = hoveredToggleButton.getAttribute('data-controls');
                 if (currentOpenMenu && currentOpenMenu !== hoveredDropdownId) {
                     toggleMenuDropdown(hoveredToggleButton);
                 }
             });
         });

            menuItems.forEach(item => {
             item.addEventListener('click', (e) => {
                 const buttonTarget = e.target.closest('button[role="menuitem"]');
                 if (!buttonTarget) return;
                 if (buttonTarget.getAttribute('aria-disabled') === 'true') {
                     e.preventDefault();
                     return;
                 }
                 const actionName = buttonTarget.getAttribute('data-action');
                 if (actionName && menuActionMap[actionName]) {
                     menuActionMap[actionName]();
                     closeAllMenus();
                     if (mainMenu && window.innerWidth <= 768) {
                         mainMenu.classList.remove('mobile-visible');
                         document.body.classList.remove('menu-open');
                         if (mobileMenuToggle) mobileMenuToggle.setAttribute('aria-expanded', 'false');
                     }
                 }
             });
             item.addEventListener('mouseup', (e) => e.target.blur());
         });
        mainMenu?.addEventListener('keydown', (e) => { const target = e.target; const targetButton = target.closest('button'); if (!targetButton || (!targetButton.classList.contains('menu-toggle') && targetButton.getAttribute('role') !== 'menuitem')) return; const currentDropdownId = targetButton.closest('.menu-dropdown')?.id; const isToggle = targetButton.classList.contains('menu-toggle'); const isItem = targetButton.getAttribute('role') === 'menuitem'; let nextElement = null; let currentList = null; let currentIndex = -1; if (isItem && currentDropdownId) { currentList = Array.from(document.querySelectorAll(`#${currentDropdownId} button[role="menuitem"]`)); currentIndex = currentList.indexOf(targetButton); } switch (e.key) { case 'ArrowDown': e.preventDefault(); if (isToggle && targetButton.getAttribute('aria-expanded') === 'true') { nextElement = document.querySelector(`#${targetButton.getAttribute('data-controls')} button[role="menuitem"]:not([aria-disabled="true"])`); } else if (isItem && currentList && currentIndex < currentList.length - 1) { for(let i = currentIndex + 1; i < currentList.length; i++) { if (currentList[i].getAttribute('aria-disabled') !== 'true') { nextElement = currentList[i]; break; } } if (!nextElement) { nextElement = currentList.find(item => item.getAttribute('aria-disabled') !== 'true'); } } else if (isItem && currentList && currentIndex === currentList.length - 1) { nextElement = currentList.find(item => item.getAttribute('aria-disabled') !== 'true'); } break; case 'ArrowUp': e.preventDefault(); if (isItem && currentList && currentIndex > 0) { for(let i = currentIndex - 1; i >= 0; i--) { if (currentList[i].getAttribute('aria-disabled') !== 'true') { nextElement = currentList[i]; break; } } if (!nextElement) { const toggle = targetButton.closest('.menu-group')?.querySelector('.menu-toggle'); nextElement = toggle; } } else if (isItem && currentList && currentIndex === 0) { const toggle = targetButton.closest('.menu-group')?.querySelector('.menu-toggle'); nextElement = toggle; } else if (isItem && currentList) { const enabledItems = currentList.filter(item => item.getAttribute('aria-disabled') !== 'true'); nextElement = enabledItems[enabledItems.length - 1]; } break; case 'ArrowRight': if (isToggle) { e.preventDefault(); const allToggles = Array.from(menuToggles); const currentToggleIndex = allToggles.indexOf(targetButton); const nextToggleIndex = (currentToggleIndex + 1) % allToggles.length; nextElement = allToggles[nextToggleIndex]; if (targetButton.getAttribute('aria-expanded') === 'true') { closeAllMenus(); toggleMenuDropdown(nextElement); } } break; case 'ArrowLeft': if (isToggle) { e.preventDefault(); const allToggles = Array.from(menuToggles); const currentToggleIndex = allToggles.indexOf(targetButton); const prevToggleIndex = (currentToggleIndex - 1 + allToggles.length) % allToggles.length; nextElement = allToggles[prevToggleIndex]; if (targetButton.getAttribute('aria-expanded') === 'true') { closeAllMenus(); toggleMenuDropdown(nextElement); } } break; case 'Enter': case ' ': if (isToggle || isItem) { e.preventDefault(); targetButton.click(); } break; case 'Escape': /* Handled globally */ break; case 'Tab': closeAllMenus(); if (mainMenu && window.innerWidth <= 768) { mainMenu.classList.remove('mobile-visible'); document.body.classList.remove('menu-open'); if(mobileMenuToggle) mobileMenuToggle.setAttribute('aria-expanded', 'false'); } break; case 'Home': if (isItem && currentList) { e.preventDefault(); nextElement = currentList.find(item => item.getAttribute('aria-disabled') !== 'true'); } break; case 'End': if (isItem && currentList) { e.preventDefault(); const enabledItems = currentList.filter(item => item.getAttribute('aria-disabled') !== 'true'); nextElement = enabledItems[enabledItems.length - 1]; } break; } if (nextElement) { nextElement.focus(); } });
            document.addEventListener('click', (e) => { const clickedInsideMenu = mainMenu?.contains(e.target); const clickedOnMobileToggle = mobileMenuToggle?.contains(e.target); if (!clickedInsideMenu && !clickedOnMobileToggle) { closeAllMenus(); if (mainMenu && window.innerWidth <= 768 && mainMenu.classList.contains('mobile-visible')) { mainMenu.classList.remove('mobile-visible'); document.body.classList.remove('menu-open'); if(mobileMenuToggle) mobileMenuToggle.setAttribute('aria-expanded', 'false'); } } const isClickInsideSuggestions = e.target.closest('.suggestions-container'); const isClickInsideTagInputWrapper = e.target.closest('.input-wrapper')?.contains(tagInput); const isClickInsideSearchInputWrapper = e.target.closest('.input-wrapper')?.contains(searchInput); if (!isClickInsideSuggestions && !isClickInsideTagInputWrapper && tagSuggestions?.style.display === 'block') hideSuggestions(); if (!isClickInsideSuggestions && !isClickInsideSearchInputWrapper && searchSuggestions?.style.display === 'block') hideSuggestions(); const isClickInsideTagList = e.target.closest('#tagDisplayContainer'); const isClickInsideActions = e.target.closest('#tagActionsArea'); const isClickInsideInputs = e.target.closest('.input-area, .filter-area'); const isClickInsideButtons = e.target.closest('.action-button-row, .dark-mode-toggle'); const isClickInsideMessage = e.target.closest('.message'); const isClickInsideCurrentEntries = e.target.closest('.current-entries-section'); if (!isClickInsideTagList && !isClickInsideActions && !isClickInsideInputs && !isClickInsideButtons && !isClickInsideMessage && !isClickInsideCurrentEntries && !isClickInsideSuggestions && !clickedInsideMenu && !clickedOnMobileToggle && tagBeingEditedValue === null) { if (!e.ctrlKey && !e.metaKey && !e.shiftKey) { if (tagDisplayArea?.querySelector('span.tag-item[aria-selected="true"]')) { hideTagActions(true); setInitialTagFocus(); } } } });
            mobileMenuToggle?.addEventListener('click', (e) => { e.stopPropagation(); const isExpanded = mobileMenuToggle.getAttribute('aria-expanded') === 'true'; mobileMenuToggle.setAttribute('aria-expanded', String(!isExpanded)); if(mainMenu) mainMenu.classList.toggle('mobile-visible'); document.body.classList.toggle('menu-open'); if(!isExpanded) { mainMenu?.querySelector('.menu-toggle')?.focus(); } else { closeAllMenus(); } });

                // Global Keydown Listener
            document.addEventListener('keydown', (event) => {
                const el = event.target; const isInputFocused = el?.tagName === 'INPUT' || el?.tagName === 'TEXTAREA'; const isMenuFocused = mainMenu?.contains(el); const isSuggestionVisible = tagSuggestions?.style.display === 'block' || searchSuggestions?.style.display === 'block'; const blockNativeUndoRedo = (el === tagInput && tagBeingEditedValue !== null) || el?.id === 'actionEntryInput'; const isMac = navigator.platform.toUpperCase().includes('MAC'); const isCtrlOrCmd = event.ctrlKey || event.metaKey;

                // Escape Key Handling
                if (event.key === 'Escape') {
                    if (isSuggestionVisible) {
                        hideSuggestions();
                        event.preventDefault();
                        event.stopPropagation();
                        return;
                    } else if (mainMenu?.classList.contains('mobile-visible')) {
                        mobileMenuToggle?.click();
                        event.preventDefault();
                        event.stopPropagation();
                        return;
                    } else if (currentOpenMenu) {
                        const parentToggle = document.querySelector(`.menu-toggle[data-controls="${currentOpenMenu}"]`);
                        parentToggle?.focus();
                        closeAllMenus();
                        event.preventDefault();
                        event.stopPropagation();
                        return;
                    } else if (tagBeingEditedValue !== null && (el === tagInput || document.activeElement === tagInput)) {
                        cancelUpdateBtn?.click();
                        event.preventDefault();
                        return;
                    }
                }

                // Input/Menu Focus Context Check - prevent global shortcuts from overriding standard input behavior
                if ((isInputFocused || isMenuFocused || currentOpenMenu || mainMenu?.classList.contains('mobile-visible')) && !['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', ' ', 'Escape', 'Tab', 'Home', 'End'].includes(event.key) ) {
                    // Check specific ctrl/cmd combinations that should be allowed natively *or* handled later
                    if (isCtrlOrCmd && (event.key.toLowerCase() === 'z' || event.key.toLowerCase() === 'y')) {
                        // Undo/Redo: Let it pass if not specifically blocked, will be handled below
                        if (blockNativeUndoRedo || !isInputFocused) { /* Fall through */ } else { return; }
                    } else if (isCtrlOrCmd && event.key.toLowerCase() === 'a' && isInputFocused) {
                        return; // Allow native select all in inputs
                    } else if (isCtrlOrCmd && event.key.toLowerCase() === 'c' && isInputFocused) {
                         return; // Allow native copy in inputs
                     } else if (isCtrlOrCmd && event.key.toLowerCase() === 'x' && isInputFocused) {
                        return; // Allow native cut in inputs
                    } else if (isCtrlOrCmd && event.key.toLowerCase() === 'v' && isInputFocused) {
                        return; // Allow native paste in inputs
                    } else if (isCtrlOrCmd && (event.key.toLowerCase() === 's' || event.key.toLowerCase() === 'o')) {
                        // Save/Open might be handled below, let them pass through the check for now
                        /* Fall through */
                    }
                    else {
                        // Allow other regular typing keys etc. if input/menu focused
                        return;
                    }
                }

                // Define Shortcut Keys
                const undoKeys = isCtrlOrCmd && event.key.toLowerCase() === 'z';
                const redoKeys = (isMac && event.metaKey && event.shiftKey && event.key.toLowerCase() === 'z') || (!isMac && event.ctrlKey && event.key.toLowerCase() === 'y');
                const saveKeys = isCtrlOrCmd && event.key.toLowerCase() === 's';
                const saveAsKeys = isCtrlOrCmd && event.shiftKey && event.key.toLowerCase() === 's';
                const openKeys = isCtrlOrCmd && event.key.toLowerCase() === 'o';
                const selectAllKeys = isCtrlOrCmd && event.key.toLowerCase() === 'a' && !isInputFocused; // Only trigger global select all if NOT in an input
                const copyKeys = isCtrlOrCmd && event.key.toLowerCase() === 'c'; // Check for Copy shortcut

                // Handle Global Shortcuts
                if (undoKeys && !redoKeys) { // Undo (Ctrl+Z)
                    const undoMenuItem = document.getElementById('menu-undo');
                    if (undoMenuItem && undoMenuItem.getAttribute('aria-disabled') !== 'true') {
                     event.preventDefault();
                     undo();
                 }
             }
                else if (redoKeys) { // Redo (Ctrl+Y or Cmd+Shift+Z)
                    const redoMenuItem = document.getElementById('menu-redo');
                    if (redoMenuItem && redoMenuItem.getAttribute('aria-disabled') !== 'true') {
                        event.preventDefault();
                        redo();
                    }
                }
                else if (saveKeys && !event.shiftKey && tagBeingEditedValue === null) { // Save (Ctrl+S)
                    event.preventDefault();
                    const saveMenuItem = document.getElementById('menu-save');
                    if (saveMenuItem && saveMenuItem.getAttribute('aria-disabled') !== 'true') {
                        saveFile();
                    } else if (!hasUnsavedChanges) {
                        showMessage("No unsaved changes to save.", "info", 1500);
                    }
                }
                else if (saveAsKeys && tagBeingEditedValue === null) { // Save As (Ctrl+Shift+S)
                    event.preventDefault();
                    const saveAsMenuItem = document.getElementById('menu-save-as');
                    if (saveAsMenuItem && saveAsMenuItem.getAttribute('aria-disabled') !== 'true') {
                        saveFileAs();
                    }
                }
                else if (openKeys && tagBeingEditedValue === null) { // Open (Ctrl+O)
                    event.preventDefault();
                    const openMenuItem = document.getElementById('menu-open');
                    if (openMenuItem && openMenuItem.getAttribute('aria-disabled') !== 'true') {
                        openFile();
                    }
                }
                 else if (selectAllKeys && tagBeingEditedValue === null) { // Select All Tags (Ctrl+A, not in input)
                     const selectAllMenuItem = document.getElementById('menu-select-all');
                     if (selectAllMenuItem && selectAllMenuItem.getAttribute('aria-disabled') !== 'true') {
                         event.preventDefault();
                         menuActionMap.selectAllTags();
                     }
                 }
                 else if (copyKeys && !isInputFocused && tagBeingEditedValue === null) { // Copy Selected Tags (Ctrl+C, not in input)
                    const copyMenuItem = document.getElementById('menu-copy');
                    // Check if the action is enabled via the menu item state
                    if (copyMenuItem && copyMenuItem.getAttribute('aria-disabled') !== 'true') {
                        event.preventDefault(); // Prevent any default browser action for Ctrl+C when not in an input
                        copySelectedTags();
                    }
                }

            }); // End of document.addEventListener('keydown', ...)

        // Before Unload Listener
window.addEventListener('beforeunload', (event) => { if (hasUnsavedChanges) { const message = 'You have unsaved changes. Are you sure you want to leave?'; event.preventDefault(); event.returnValue = message; return message; } });

        // Drag and Drop
        if (container) { let dragEnterCounter = 0; container.addEventListener('dragenter', (event) => { event.preventDefault(); event.stopPropagation(); dragEnterCounter++; if (event.dataTransfer?.types.includes('Files') && tagBeingEditedValue === null) { container.classList.add('drag-over'); event.dataTransfer.dropEffect = 'copy'; } else { event.dataTransfer.dropEffect = 'none'; } }); container.addEventListener('dragover', (event) => { event.preventDefault(); event.stopPropagation(); if (event.dataTransfer?.types.includes('Files') && tagBeingEditedValue === null) { event.dataTransfer.dropEffect = 'copy'; } else { event.dataTransfer.dropEffect = 'none'; } }); container.addEventListener('dragleave', (event) => { event.preventDefault(); event.stopPropagation(); dragEnterCounter--; if (dragEnterCounter <= 0) { container.classList.remove('drag-over'); dragEnterCounter = 0; } }); container.addEventListener('drop', async (event) => { event.preventDefault(); event.stopPropagation(); container.classList.remove('drag-over'); dragEnterCounter = 0; if (tagBeingEditedValue !== null) { showMessage("Finish editing before dropping a file.", "info"); return; } const files = event.dataTransfer?.files; if (!files || files.length === 0) { showMessage('No files dropped.', 'info'); return; } const jsonFile = Array.from(files).find(f => f.type === 'application/json' || f.name.toLowerCase().endsWith('.json')); if (!jsonFile) { showMessage('No valid .json file found in drop.', 'error'); return; } if (!(await confirmDiscardUnsaved())) { showMessage("Drop operation cancelled.", "info"); return; } try { const contents = await jsonFile.text(); let originalParsedData; try { originalParsedData = JSON.parse(contents); } catch (parseError) { throw new Error(`Invalid JSON format in dropped file "${jsonFile.name}".`); } const { dataToLoad, backupLoaded, sourceName } = await checkForAndHandleBackup(jsonFile.name, originalParsedData); resetStateBeforeLoad(); const result = processImportedJsonData(dataToLoad, sourceName, true); if (result.success) { tags = result.loadedTags; currentFileName = jsonFile.name; currentFileHandle = null; if (backupLoaded) { hasUnsavedChanges = true; } else { hasUnsavedChanges = false; } finalizeLoad(); let finalMsg = result.message; if (supportsFileSystemAccess) { /* Removed explicit mention of buttons */ } else { finalMsg += ` Changes are backed up to browser storage for "${currentFileName}".`; } showMessage(finalMsg, backupLoaded ? 'info' : 'success', 6000); } else { resetStateBeforeLoad(); finalizeLoad(); } } catch (error) { console.error("Error reading/parsing dropped file:", error); showMessage(`Error processing dropped file "${jsonFile.name}": ${error.message}`, 'error'); resetStateBeforeLoad(); finalizeLoad(); } }); } else { console.error("Dropzone container element not found!"); }

// Handle window resize
window.addEventListener('resize', () => {
    if (tagTooltip) tagTooltip.classList.remove('visible');
    if (entryTooltip) entryTooltip.classList.remove('visible');
    if (window.innerWidth > 768) { closeAllMenus(); }
});

        // --- Initial Load, includes initial menu state ---
resetStateBeforeLoad();
finalizeLoad();

        // --- Final Check & Initial State ---
const essentialIds = [ 'tagInput', 'addTagBtn', 'tagDisplayContainer', 'tagAreaInitialPlaceholder', 'tagDisplayArea', 'copySelectedTagsBtn', 'removeSelectedTagsBtn', 'tagActionsArea', 'searchInput', 'entryFilterInput', 'messageArea', 'currentFileNameDisplay', 'tagCountDisplay', 'currentEntriesDisplayArea', 'currentEntriesPlaceholder', 'currentEntriesCountDisplay', 'tagSuggestions', 'searchSuggestions', 'main-menu', 'mobile-menu-toggle', 'menu-open', 'menu-save', 'menu-save-as', 'menu-close', 'menu-undo', 'menu-redo', 'menu-copy', 'menu-remove', 'menu-select-all', 'menu-sort', 'menu-theme', 'menu-about' ];

const missing = essentialIds.filter(id => !document.getElementById(id));
if (missing.length > 0 || !container) {
    console.error("Critical UI elements missing:", missing.join(', ') || 'container');
    showMessage("Initialization error: Core UI elements missing. App may not function correctly.", "error", 10000);
} else {
    console.log("KeyWordManager Initialized Successfully");
}

    }); // --- End DOMContentLoaded listener ---
</script>
</body>
</html>